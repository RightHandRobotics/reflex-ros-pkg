diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/async_poll.c /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/async_poll.c
#include "async_poll.h"						#include "async_poll.h"
							      >	#include "tactile.h"
							      >	#include "dmxl.h"
							      >	#include "enc.h"
							      >	#include <stdbool.h>
							      >	#include "systime.h"
							      >	#include <stdio.h>

#define NUM_STATE_FUNCTIONS 14				      |	#define ASYNC_POLL_NUM_PORTS 9

typedef void (*async_poll_fptr)(uint8_t poll_arg);		typedef void (*async_poll_fptr)(uint8_t poll_arg);

typedef struct							typedef struct
{								{
  const async_poll_fptr fptr;					  const async_poll_fptr fptr;
  const uint8_t arg;						  const uint8_t arg;
  int * const poll_state;					  int * const poll_state;
} stateMachine;						      |	} poll_target_t;

static uint32_t asyncStartTime = 0;			      |	static uint32_t async_poll_start_time_us = 0;
							      >	static uint_fast8_t async_poll_complete = 0;

static stateMachine stateMachines[NUM_STATE_FUNCTIONS] =      |	static poll_target_t poll_targets[ASYNC_POLL_NUM_PORTS] = 
{								{
  { takktile_poll_nonblocking_tick, 0, (int *)(&takktilePollS |	  { tactile_poll_nonblocking_tick, 0, (int *)(&tactile_poll_s
  { takktile_poll_nonblocking_tick, 1, (int *)(&takktilePollS |	  { tactile_poll_nonblocking_tick, 1, (int *)(&tactile_poll_s
  { takktile_poll_nonblocking_tick, 2, (int *)(&takktilePollS |	  { tactile_poll_nonblocking_tick, 2, (int *)(&tactile_poll_s
  { dmxl_poll_nonblocking_tick    , 0, (int *)(&dmxl_poll_sta |	  { tactile_poll_nonblocking_tick, 3, (int *)(&tactile_poll_s
  { dmxl_poll_nonblocking_tick    , 1, (int *)(&dmxl_poll_sta |	  { dmxl_poll_nonblocking_tick   , 0, (int *)(&dmxl_poll_stat
  { dmxl_poll_nonblocking_tick    , 2, (int *)(&dmxl_poll_sta |	  { dmxl_poll_nonblocking_tick   , 1, (int *)(&dmxl_poll_stat
  { dmxl_poll_nonblocking_tick    , 3, (int *)(&dmxl_poll_sta |	  { dmxl_poll_nonblocking_tick   , 2, (int *)(&dmxl_poll_stat
  { enc_poll_nonblocking_tick     , 0, (int *)(&enc_poll_stat |	  { dmxl_poll_nonblocking_tick   , 3, (int *)(&dmxl_poll_stat
  { enc_poll_nonblocking_tick     , 1, (int *)(&enc_poll_stat |	  { enc_poll_nonblocking_tick    , 0, (int *)(&enc_poll_state
  { enc_poll_nonblocking_tick     , 2, (int *)(&enc_poll_stat |	};
  { imu_poll_nonblocking_tick     , 0, (int *)(&imu_poll_stat <
  { imu_poll_nonblocking_tick     , 1, (int *)(&imu_poll_stat <
  { imu_poll_nonblocking_tick     , 2, (int *)(&imu_poll_stat <
  { imu_poll_nonblocking_tick     , 3, (int *)(&imu_poll_stat <
}; 							      <

void asyncInit()					      |	void async_poll_init()
{								{
  for (uint_fast8_t i = 0; i < NUM_STATE_FUNCTIONS; i++)      |	}
							      >
							      >	async_poll_tick_result_t async_poll_tick()
							      >	{
							      >	  if (async_poll_complete)
							      >	    return APT_COMPLETE;
							      >	  bool all_done = true;
							      >	  for (uint_fast8_t i = 0; i < ASYNC_POLL_NUM_PORTS; i++)
							      >	  {
							      >	    if (*(poll_targets[i].poll_state) == (int)ASYNC_POLL_DONE
							      >	      continue;
							      >	    all_done = false;
							      >	    poll_targets[i].fptr(poll_targets[i].arg);
							      >	  }
							      >	  if (all_done)
  {								  {
    if (i < 3 || i > 6)					      |	    async_poll_complete = 1;
      *stateMachines[i].poll_state = 0;			      |	    return APT_JUST_FINISHED;
    else						      <
      *stateMachines[i].poll_state = ASYNC_POLL_DONE;	      <
    stateMachines[i].fptr(stateMachines[i].arg);	      <
  }								  }
  asyncStartTime = SYSTIME;				      |	  return APT_BUSY;
}								}

uint8_t asyncUpdate()					      |	void async_poll_start()
{								{
  uint8_t allDone = 1;					      |	  for (uint_fast8_t i = 0; i < ASYNC_POLL_NUM_PORTS; i++)
							      <
  // if stateMachines did not finish before MAX_CYCLE_PERIOD, <
  // if (SYSTIME - asyncStartTime > MAX_CYCLE_PERIOD)	      <
  //   asyncInit();					      <
							      <
  for (uint_fast8_t i = 0; i < NUM_STATE_FUNCTIONS; i++)      <
  {								  {
    if (!(*(stateMachines[i].poll_state) == (int)ASYNC_POLL_D |	    // force them all to the DONE state, in case somebody was
    {							      |	    // so their state machines get the DONE -> IDLE transitio
      allDone = 0;					      |	    *poll_targets[i].poll_state = ASYNC_POLL_DONE;
      stateMachines[i].fptr(stateMachines[i].arg);	      |	    poll_targets[i].fptr(poll_targets[i].arg); // get it star
    }							      <
  }								  }
  if (allDone)                // if all stateMachines finishe |	  async_poll_complete = 0;
    asyncInit();              // restart		      |	  async_poll_start_time_us = SYSTIME;
							      >	}

  return allDone;					      <
}							      <diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/async_poll.h /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/async_poll.h
#ifndef ASYNC_POLL_H						#ifndef ASYNC_POLL_H
#define ASYNC_POLL_H						#define ASYNC_POLL_H

#define ASYNC_POLL_DONE 0xffffffff			      |	typedef enum
#define MAX_CYCLE_PERIOD 25000 // 33333			      |	{
							      |	  APT_BUSY,
#include <stdint.h>					      |	  APT_JUST_FINISHED,
#include <stdio.h>					      |	  APT_COMPLETE
#include <stdbool.h>					      |	} async_poll_tick_result_t;

#include "takktile.h"					      |	void async_poll_init();
#include "dmxl.h"					      |	async_poll_tick_result_t async_poll_tick();
#include "enc.h"					      |	void async_poll_start();
#include "imu.h"					      <
#include "systime.h"					      <

							      |	#define ASYNC_POLL_DONE 0xffffffff
void asyncInit();					      <
uint8_t asyncUpdate();					      <

#endif								#endif

Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/: bin
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: config.c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: config.h
diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/console.c /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/console.c
#include "console.h"						#include "console.h"
							      >	#include "stm32f4xx.h"

// pin connections						// pin connections
// PE0 = uart8 TX on AF8					// PE0 = uart8 TX on AF8
// PE1 = uart8 RX on AF8					// PE1 = uart8 RX on AF8

#define PORTE_RX 0						#define PORTE_RX 0
#define PORTE_TX 1						#define PORTE_TX 1

void consoleInit()					      |	static volatile uint8_t s_console_init_complete = 0;
							      >
							      >	void console_init()
{								{
							      >	  s_console_init_complete = 1;
  RCC->AHB1ENR |= RCC_AHB1ENR_GPIOEEN;				  RCC->AHB1ENR |= RCC_AHB1ENR_GPIOEEN;
  RCC->APB1ENR |= RCC_APB1ENR_UART8EN;				  RCC->APB1ENR |= RCC_APB1ENR_UART8EN;
  GPIOE->MODER   |= (0x2) << (PORTE_TX * 2);			  GPIOE->MODER   |= (0x2) << (PORTE_TX * 2);
  GPIOE->AFR[0]  |= (0x8) << (PORTE_TX * 4);			  GPIOE->AFR[0]  |= (0x8) << (PORTE_TX * 4);
  // RX not used at the moment. TX only used for stdout		  // RX not used at the moment. TX only used for stdout
  UART8->CR1 &= ~USART_CR1_UE;					  UART8->CR1 &= ~USART_CR1_UE;
  UART8->CR1 |=  USART_CR1_TE | USART_CR1_RE;			  UART8->CR1 |=  USART_CR1_TE | USART_CR1_RE;
  // we want 1 megabit. do this with mantissa=2 and fraction 	  // we want 1 megabit. do this with mantissa=2 and fraction 
  UART8->BRR  = (22 << 4) | 12;//42000000/115200;//(((uint16_ |	  UART8->BRR  = (((uint16_t)2) << 4) | 10;
  UART8->CR1 |=  USART_CR1_UE;					  UART8->CR1 |=  USART_CR1_UE;
}								}
// (22 << 4) | 12;  10110 1100 				      <

int consolePrint(const uint8_t *buffer, uint32_t len)	      |	void console_send_block(const uint8_t *buf, uint32_t len)
{								{
  int startTime = SYSTIME;				      |	  if (!s_console_init_complete)
  							      |	    console_init();
  // make sure transmission buffer is clear		      <
  while (!(UART8->SR & USART_SR_TXE) && (SYSTIME - startTime  <
  if (SYSTIME - startTime > UART_TIMEOUT)		      <
    return -1;						      <
							      <
  // start transmission					      <
  for (uint32_t i = 0; i < len; i++)				  for (uint32_t i = 0; i < len; i++)
  {								  {
    while (!(UART8->SR & USART_SR_TXE) && (SYSTIME - startTim |	    while (!(UART8->SR & USART_SR_TXE)) { } // wait for tx bu
    UART8->DR = buffer[i];				      |	    UART8->DR = buf[i];
    if (SYSTIME - startTime > UART_TIMEOUT)		      <
      return -1;					      <
  }								  }
  // while (!(UART8->SR & USART_SR_TC)); // wait for TX to fi |	  while (!(UART8->SR & USART_SR_TC)) { } // wait for TX to fi
							      |	  //for (volatile int i = 0; i < 100000; i++) { } // give usb
  // return number of bytes transmitted			      <
  return len;						      <
}								}

diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/console.h /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/console.h
#ifndef CONSOLE_H						#ifndef CONSOLE_H
#define CONSOLE_H						#define CONSOLE_H

#include "./stm32/stm32f4xx.h"				      |	#include <stdint.h>
#include "systime.h"					      <
#include "config.h"					      <

void consoleInit();					      |	void console_init();
int consolePrint(const uint8_t *buf, uint32_t len);	      |	void console_send_block(const uint8_t *buf, uint32_t len);

#endif								#endif
							      >
diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/delay.c /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/delay.c
#include "delay.h"						#include "delay.h"
#include <stdint.h>						#include <stdint.h>

// TODO: tune this better on an oscilloscope			// TODO: tune this better on an oscilloscope

void delay_ns(uint32_t ns)					void delay_ns(uint32_t ns)
{								{
  for (volatile uint32_t i = 0; i < ns/10; i++) { }		  for (volatile uint32_t i = 0; i < ns/10; i++) { }
}								}

void delay_us(uint32_t us)					void delay_us(uint32_t us)
{								{
  for (volatile int i = 0; i < us*10; i++) { }			  for (volatile int i = 0; i < us*10; i++) { }
}								}

void delay_ms(uint32_t ms)					void delay_ms(uint32_t ms)
{								{
  for (volatile int i = 0; i < ms; i++)				  for (volatile int i = 0; i < ms; i++)
    delay_us(1000);						    delay_us(1000);
}								}

diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/delay.h /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/delay.h
#ifndef DELAY_H							#ifndef DELAY_H
#define DELAY_H							#define DELAY_H

#include <stdint.h>						#include <stdint.h>
void delay_ns(uint32_t ns);					void delay_ns(uint32_t ns);
void delay_us(uint32_t us);					void delay_us(uint32_t us);
void delay_ms(uint32_t ms);					void delay_ms(uint32_t ms);

#endif								#endif

diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/dmxl.c /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/dmxl.c
#include "dmxl.h"						#include "dmxl.h"
							      |	#include "stm32f4xx.h"
							      >	#include <stdio.h>
							      >	#include "state.h"
							      >	#include "systime.h"
							      >	#include "delay.h"

#define PORTA_DMXL_BUF_EN 10					#define PORTA_DMXL_BUF_EN 10

typedef enum							typedef enum
{								{
  DMXL_CS_IDLE        = 0,					  DMXL_CS_IDLE        = 0,
  DMXL_CS_TX          = 1,					  DMXL_CS_TX          = 1,
  DMXL_CS_POLL_STATE  = 2,					  DMXL_CS_POLL_STATE  = 2,
  DMXL_CS_POLL_DEBRIS = 3,					  DMXL_CS_POLL_DEBRIS = 3,
  DMXL_CS_PING        = 4					  DMXL_CS_PING        = 4
} dmxl_comms_state_t;						} dmxl_comms_state_t;

typedef enum							typedef enum
{								{
  DMXL_PS_PREAMBLE_0 = 0,					  DMXL_PS_PREAMBLE_0 = 0,
  DMXL_PS_PREAMBLE_1 = 1,					  DMXL_PS_PREAMBLE_1 = 1,
  DMXL_PS_ID         = 2,					  DMXL_PS_ID         = 2,
  DMXL_PS_LENGTH     = 3,					  DMXL_PS_LENGTH     = 3,
  DMXL_PS_ERROR      = 4,					  DMXL_PS_ERROR      = 4,
  DMXL_PS_PARAMETER  = 5,					  DMXL_PS_PARAMETER  = 5,
  DMXL_PS_CHECKSUM   = 6					  DMXL_PS_CHECKSUM   = 6
} dmxl_parser_state_t;						} dmxl_parser_state_t;

typedef struct							typedef struct
{								{
  GPIO_TypeDef *tx_gpio, *rx_gpio;				  GPIO_TypeDef *tx_gpio, *rx_gpio;
  uint8_t tx_pin, rx_pin, af;					  uint8_t tx_pin, rx_pin, af;
  USART_TypeDef *uart;						  USART_TypeDef *uart;
  dmxl_comms_state_t  comms_state;				  dmxl_comms_state_t  comms_state;
  dmxl_parser_state_t parser_state;				  dmxl_parser_state_t parser_state;
  uint8_t rx_pkt_len, rx_pkt_writepos, rx_checksum;		  uint8_t rx_pkt_len, rx_pkt_writepos, rx_checksum;
} dmxl_port_t;							} dmxl_port_t;

static dmxl_port_t g_dmxl_ports[NUM_DMXL] =			static dmxl_port_t g_dmxl_ports[NUM_DMXL] =
{								{
  { GPIOD, GPIOD,  8,  9, 7, USART3, DMXL_CS_IDLE, DMXL_PS_PR	  { GPIOD, GPIOD,  8,  9, 7, USART3, DMXL_CS_IDLE, DMXL_PS_PR
  { GPIOC, GPIOC, 10, 11, 8, UART4 , DMXL_CS_IDLE, DMXL_PS_PR	  { GPIOC, GPIOC, 10, 11, 8, UART4 , DMXL_CS_IDLE, DMXL_PS_PR
  { GPIOC, GPIOC,  6,  7, 8, USART6, DMXL_CS_IDLE, DMXL_PS_PR	  { GPIOC, GPIOC,  6,  7, 8, USART6, DMXL_CS_IDLE, DMXL_PS_PR
  { GPIOC, GPIOD, 12,  2, 8, UART5 , DMXL_CS_IDLE, DMXL_PS_PR	  { GPIOC, GPIOD, 12,  2, 8, UART5 , DMXL_CS_IDLE, DMXL_PS_PR
};								};

#define DMXL_RING_LEN 256					#define DMXL_RING_LEN 256
static volatile uint8_t  g_dmxl_ring[NUM_DMXL][DMXL_RING_LEN]	static volatile uint8_t  g_dmxl_ring[NUM_DMXL][DMXL_RING_LEN]
static volatile uint16_t g_dmxl_ring_rpos[NUM_DMXL] = {0};	static volatile uint16_t g_dmxl_ring_rpos[NUM_DMXL] = {0};
static volatile uint16_t g_dmxl_ring_wpos[NUM_DMXL] = {0};	static volatile uint16_t g_dmxl_ring_wpos[NUM_DMXL] = {0};
static volatile uint8_t  g_dmxl_rx_pkt[NUM_DMXL][256];		static volatile uint8_t  g_dmxl_rx_pkt[NUM_DMXL][256];
static volatile dmxl_control_mode_t dmxl_control_mode = DMXL_	static volatile dmxl_control_mode_t dmxl_control_mode = DMXL_
static volatile uint8_t divider_is_sent[NUM_DMXL] = {0};	static volatile uint8_t divider_is_sent[NUM_DMXL] = {0};

dmxl_async_poll_state_t dmxl_poll_states[NUM_DMXL] =		dmxl_async_poll_state_t dmxl_poll_states[NUM_DMXL] =
  { DPS_DONE, DPS_DONE, DPS_DONE, DPS_DONE };			  { DPS_DONE, DPS_DONE, DPS_DONE, DPS_DONE };

static void dmxl_read_data(const uint8_t port_idx, const uint	static void dmxl_read_data(const uint8_t port_idx, const uint
                           const uint8_t data_len, const uint	                           const uint8_t data_len, const uint
static void dmxl_write_data(const uint8_t port_idx, const uin	static void dmxl_write_data(const uint8_t port_idx, const uin
                            const uint8_t data_len, const uin	                            const uint8_t data_len, const uin
                            const uint8_t *data);		                            const uint8_t *data);
static uint8_t dmxl_send_ping(const uint8_t port_idx, const u	static uint8_t dmxl_send_ping(const uint8_t port_idx, const u

// put in ramfunc sector ?					// put in ramfunc sector ?
static inline void dmxl_push_byte(const uint8_t dmxl_port, co	static inline void dmxl_push_byte(const uint8_t dmxl_port, co
{								{
  if (dmxl_port >= NUM_DMXL)					  if (dmxl_port >= NUM_DMXL)
    return;							    return;
  g_dmxl_ring[dmxl_port][g_dmxl_ring_wpos[dmxl_port]] = byte;	  g_dmxl_ring[dmxl_port][g_dmxl_ring_wpos[dmxl_port]] = byte;
  if (++g_dmxl_ring_wpos[dmxl_port] >= DMXL_RING_LEN)		  if (++g_dmxl_ring_wpos[dmxl_port] >= DMXL_RING_LEN)
    g_dmxl_ring_wpos[dmxl_port] = 0;				    g_dmxl_ring_wpos[dmxl_port] = 0;
}								}

void usart3_vector()						void usart3_vector()
{								{
  volatile uint8_t __attribute__((unused)) sr = USART3->SR; /	  volatile uint8_t __attribute__((unused)) sr = USART3->SR; /
  dmxl_push_byte(0, USART3->DR);				  dmxl_push_byte(0, USART3->DR);
}								}

void uart4_vector()						void uart4_vector()
{								{
  volatile uint8_t __attribute__((unused)) sr = UART4->SR; //	  volatile uint8_t __attribute__((unused)) sr = UART4->SR; //
  dmxl_push_byte(1, UART4->DR);					  dmxl_push_byte(1, UART4->DR);
}								}

void uart5_vector()						void uart5_vector()
{								{
  volatile uint8_t __attribute__((unused)) sr = UART5->SR; //	  volatile uint8_t __attribute__((unused)) sr = UART5->SR; //
  dmxl_push_byte(3, UART5->DR);					  dmxl_push_byte(3, UART5->DR);
}								}

void usart6_vector()						void usart6_vector()
{								{
  volatile uint8_t __attribute__((unused)) sr = USART6->SR; /	  volatile uint8_t __attribute__((unused)) sr = USART6->SR; /
  dmxl_push_byte(2, USART6->DR);				  dmxl_push_byte(2, USART6->DR);
}								}

void dmxl_set_usart_baud(const uint_fast8_t dmxl_idx, int bau	void dmxl_set_usart_baud(const uint_fast8_t dmxl_idx, int bau
{								{
  USART_TypeDef *u = g_dmxl_ports[dmxl_idx].uart;		  USART_TypeDef *u = g_dmxl_ports[dmxl_idx].uart;
  if (baud == 57600)						  if (baud == 57600)
  {								  {
    if (u == USART6)						    if (u == USART6)
      u->BRR = (((uint16_t)91) << 4) | 2;			      u->BRR = (((uint16_t)91) << 4) | 2;
    else							    else
      u->BRR = (((uint16_t)45) << 4) | 9;			      u->BRR = (((uint16_t)45) << 4) | 9;
  }								  }
  else if (baud == 250000)					  else if (baud == 250000)
  {								  {
    if (u == USART6)						    if (u == USART6)
      u->BRR = (((uint16_t)21) << 4);				      u->BRR = (((uint16_t)21) << 4);
    else							    else
      u->BRR = (((uint16_t)10) << 4) | 8;			      u->BRR = (((uint16_t)10) << 4) | 8;
  }								  }
  else if (baud == 1000000)					  else if (baud == 1000000)
  {								  {
    if (u == USART6)						    if (u == USART6)
      u->BRR = (((uint16_t)5) << 4) |  4;			      u->BRR = (((uint16_t)5) << 4) |  4;
    else							    else
      u->BRR = (((uint16_t)2) << 4) | 10;			      u->BRR = (((uint16_t)2) << 4) | 10;
  }								  }
  else								  else
    printf("ahhh unhandled baud rate: %d\r\n", baud);		    printf("ahhh unhandled baud rate: %d\r\n", baud);
}								}

void dmxl_init()						void dmxl_init()
{								{
  printf("dmxl_init()\r\n");					  printf("dmxl_init()\r\n");
  RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN |				  RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN |
                  RCC_AHB1ENR_GPIOCEN |				                  RCC_AHB1ENR_GPIOCEN |
                  RCC_AHB1ENR_GPIODEN;				                  RCC_AHB1ENR_GPIODEN;
  RCC->APB1ENR |= RCC_APB1ENR_USART3EN |			  RCC->APB1ENR |= RCC_APB1ENR_USART3EN |
                  RCC_APB1ENR_UART4EN  |			                  RCC_APB1ENR_UART4EN  |
                  RCC_APB1ENR_UART5EN;				                  RCC_APB1ENR_UART5EN;
  RCC->APB2ENR |= RCC_APB2ENR_USART6EN;				  RCC->APB2ENR |= RCC_APB2ENR_USART6EN;

  for (int i = 0; i < NUM_DMXL; i++)				  for (int i = 0; i < NUM_DMXL; i++)
  {								  {
    dmxl_port_t *dp = &g_dmxl_ports[i];				    dmxl_port_t *dp = &g_dmxl_ports[i];
    dp->tx_gpio->MODER |= (uint32_t)2 << (dp->tx_pin * 2); //	    dp->tx_gpio->MODER |= (uint32_t)2 << (dp->tx_pin * 2); //
    dp->rx_gpio->MODER |= (uint32_t)2 << (dp->rx_pin * 2); //	    dp->rx_gpio->MODER |= (uint32_t)2 << (dp->rx_pin * 2); //

    if (dp->tx_pin >= 8)					    if (dp->tx_pin >= 8)
      dp->tx_gpio->AFR[1] |= (uint32_t)dp->af << ((dp->tx_pin	      dp->tx_gpio->AFR[1] |= (uint32_t)dp->af << ((dp->tx_pin
    else							    else
      dp->tx_gpio->AFR[0] |= (uint32_t)dp->af << (dp->tx_pin 	      dp->tx_gpio->AFR[0] |= (uint32_t)dp->af << (dp->tx_pin 

    if (dp->rx_pin >= 8)					    if (dp->rx_pin >= 8)
      dp->rx_gpio->AFR[1] |= (uint32_t)dp->af << ((dp->rx_pin	      dp->rx_gpio->AFR[1] |= (uint32_t)dp->af << ((dp->rx_pin
    else							    else
      dp->rx_gpio->AFR[0] |= (uint32_t)dp->af << (dp->rx_pin 	      dp->rx_gpio->AFR[0] |= (uint32_t)dp->af << (dp->rx_pin 

    USART_TypeDef *u = dp->uart;				    USART_TypeDef *u = dp->uart;
    u->CR1 &= ~USART_CR1_UE; // make sure it's off while we c	    u->CR1 &= ~USART_CR1_UE; // make sure it's off while we c
    u->CR1 |=  USART_CR1_RE; // don't enable the transmitter 	    u->CR1 |=  USART_CR1_RE; // don't enable the transmitter 

    dmxl_set_usart_baud(i, 250000);				    dmxl_set_usart_baud(i, 250000);
    /*								    /*
    if (u == USART6) // running on APB2 = 84 MHz		    if (u == USART6) // running on APB2 = 84 MHz
      u->BRR = (((uint16_t)5) << 4) | 4; // 5.25 mantissa = 5	      u->BRR = (((uint16_t)5) << 4) | 4; // 5.25 mantissa = 5
    else // running on APB1 = 42 MHz				    else // running on APB1 = 42 MHz
      u->BRR = (((uint16_t)2) << 4) | 10;// 2.625 mantissa = 	      u->BRR = (((uint16_t)2) << 4) | 10;// 2.625 mantissa = 
    */								    */
    u->CR1 |=  USART_CR1_UE | USART_CR1_RXNEIE;			    u->CR1 |=  USART_CR1_UE | USART_CR1_RXNEIE;

    delay_us(10);						    delay_us(10);
    dmxl_set_res_divider(i, DMXL_DEFAULT_ID, 4);		    dmxl_set_res_divider(i, DMXL_DEFAULT_ID, 4);
    delay_us(10);						    delay_us(10);
    dmxl_set_multiturn_offset(i, DMXL_DEFAULT_ID, 13000);  //	    dmxl_set_multiturn_offset(i, DMXL_DEFAULT_ID, 13000);  //
  }								  }
  NVIC_SetPriority(USART3_IRQn, 2);				  NVIC_SetPriority(USART3_IRQn, 2);
  NVIC_SetPriority(UART4_IRQn, 2);				  NVIC_SetPriority(UART4_IRQn, 2);
  NVIC_SetPriority(UART5_IRQn, 2);				  NVIC_SetPriority(UART5_IRQn, 2);
  NVIC_SetPriority(USART6_IRQn, 2);				  NVIC_SetPriority(USART6_IRQn, 2);

  NVIC_EnableIRQ(USART3_IRQn);					  NVIC_EnableIRQ(USART3_IRQn);
  NVIC_EnableIRQ(UART4_IRQn);					  NVIC_EnableIRQ(UART4_IRQn);
  NVIC_EnableIRQ(UART5_IRQn);					  NVIC_EnableIRQ(UART5_IRQn);
  NVIC_EnableIRQ(USART6_IRQn);					  NVIC_EnableIRQ(USART6_IRQn);

  //GPIOD->MODER |= (1 << (8*2)); // | (1 << 9);		  //GPIOD->MODER |= (1 << (8*2)); // | (1 << 9);
  // turn on the 3.3v <-> 5v translator chip now		  // turn on the 3.3v <-> 5v translator chip now
  GPIOA->MODER |= 1 << (PORTA_DMXL_BUF_EN * 2);			  GPIOA->MODER |= 1 << (PORTA_DMXL_BUF_EN * 2);
  GPIOA->BSRRL |= 1 << PORTA_DMXL_BUF_EN;			  GPIOA->BSRRL |= 1 << PORTA_DMXL_BUF_EN;
}								}

void dmxl_set_status_return_levels()				void dmxl_set_status_return_levels()
{								{
  // see what the Status Return Level is. If it's not 1, set 	  // see what the Status Return Level is. If it's not 1, set 
  for (int i = 0; i < NUM_DMXL; i++)				  for (int i = 0; i < NUM_DMXL; i++)
  {								  {
    g_dmxl_ports[i].comms_state = DMXL_CS_POLL_DEBRIS;		    g_dmxl_ports[i].comms_state = DMXL_CS_POLL_DEBRIS;
    dmxl_read_data(i, DMXL_DEFAULT_ID, 1, 0x10);		    dmxl_read_data(i, DMXL_DEFAULT_ID, 1, 0x10);
    volatile uint32_t t_start = SYSTIME;			    volatile uint32_t t_start = SYSTIME;
    uint8_t status_return_level = 0xff;				    uint8_t status_return_level = 0xff;
    while (SYSTIME - t_start < 10000)				    while (SYSTIME - t_start < 10000)
    {								    {
      dmxl_process_rings();					      dmxl_process_rings();
      if (g_dmxl_ports[i].comms_state != DMXL_CS_POLL_DEBRIS)	      if (g_dmxl_ports[i].comms_state != DMXL_CS_POLL_DEBRIS)
      {								      {
        status_return_level = g_dmxl_rx_pkt[i][0];		        status_return_level = g_dmxl_rx_pkt[i][0];
        printf("dmxl %d status return level = %d\n", i, statu	        printf("dmxl %d status return level = %d\n", i, statu
        break;							        break;
      }								      }
    }								    }
    if (status_return_level == 0xff)				    if (status_return_level == 0xff)
      printf("couldn't poll status return level for dmxl %d\r	      printf("couldn't poll status return level for dmxl %d\r
    else if (status_return_level != 1)				    else if (status_return_level != 1)
    {								    {
      // set it to 2						      // set it to 2
      uint8_t level = 1; // only respond to READ		      uint8_t level = 1; // only respond to READ
      dmxl_write_data(i, DMXL_DEFAULT_ID, 1, 0x10, &level);	      dmxl_write_data(i, DMXL_DEFAULT_ID, 1, 0x10, &level);
    }								    }
  }								  }
}								}

void dmxl_set_baud_rates()					void dmxl_set_baud_rates()
{								{
  for (int i = 0; i < NUM_DMXL; i++)				  for (int i = 0; i < NUM_DMXL; i++)
  {								  {
    dmxl_set_usart_baud(i, 250000);				    dmxl_set_usart_baud(i, 250000);
    g_dmxl_ports[i].comms_state = DMXL_CS_PING;			    g_dmxl_ports[i].comms_state = DMXL_CS_PING;
    dmxl_send_ping(i, DMXL_DEFAULT_ID);				    dmxl_send_ping(i, DMXL_DEFAULT_ID);
    volatile uint32_t t_start = SYSTIME;			    volatile uint32_t t_start = SYSTIME;
    bool pong_received = false;					    bool pong_received = false;
    while (SYSTIME - t_start < 10000 && !pong_received)		    while (SYSTIME - t_start < 10000 && !pong_received)
    {								    {
      dmxl_process_rings();					      dmxl_process_rings();
      if (g_dmxl_ports[i].comms_state != DMXL_CS_PING)		      if (g_dmxl_ports[i].comms_state != DMXL_CS_PING)
        pong_received = true;					        pong_received = true;
    }								    }
    if (pong_received)						    if (pong_received)
    {								    {
      printf("received rx @ 250 kbit from dmxl %d\r\n", i);	      printf("received rx @ 250 kbit from dmxl %d\r\n", i);
      continue; // hooray. it's already at the target baud ra	      continue; // hooray. it's already at the target baud ra
    }								    }
    else							    else
    {								    {
      printf("no rx received from dmxl %d... trying 57600 bau	      printf("no rx received from dmxl %d... trying 57600 bau
      // this is the default out-of-the-box setup		      // this is the default out-of-the-box setup
      dmxl_set_usart_baud(i, 57600);				      dmxl_set_usart_baud(i, 57600);
      uint8_t baud_code = 7; // the dynamixel code for 250000	      uint8_t baud_code = 7; // the dynamixel code for 250000
      dmxl_write_data(i, DMXL_DEFAULT_ID, 1, 0x04, &baud_code	      dmxl_write_data(i, DMXL_DEFAULT_ID, 1, 0x04, &baud_code
      delay_ms(500);						      delay_ms(500);
      dmxl_set_usart_baud(i, 250000);				      dmxl_set_usart_baud(i, 250000);
    }								    }
  }								  }
}								}

static void dmxl_tx(const uint8_t port_idx,			static void dmxl_tx(const uint8_t port_idx,
                    const uint8_t *payload, const uint8_t pay	                    const uint8_t *payload, const uint8_t pay
{								{
  if (port_idx >= NUM_DMXL)					  if (port_idx >= NUM_DMXL)
    return; // bogus port index					    return; // bogus port index
  dmxl_port_t *dp = &g_dmxl_ports[port_idx];			  dmxl_port_t *dp = &g_dmxl_ports[port_idx];
  USART_TypeDef *u = dp->uart;					  USART_TypeDef *u = dp->uart;
  u->CR1 &= ~USART_CR1_RE; // disable the receiver during tra	  u->CR1 &= ~USART_CR1_RE; // disable the receiver during tra
  u->CR1 |=  USART_CR1_TE; // enable the transmitter		  u->CR1 |=  USART_CR1_TE; // enable the transmitter
  uint8_t csum = 0;						  uint8_t csum = 0;
  for (uint8_t i = 0; i < payload_len + 3; i++)			  for (uint8_t i = 0; i < payload_len + 3; i++)
  {								  {
    while (!(u->SR & USART_SR_TXE)) { } // wait for tx buffer	    while (!(u->SR & USART_SR_TXE)) { } // wait for tx buffer
    if (i <= 1)							    if (i <= 1)
      u->DR = 0xff; // preamble					      u->DR = 0xff; // preamble
    else if (i == payload_len + 2)				    else if (i == payload_len + 2)
    {								    {
      // send checksum						      // send checksum
      u->DR = ~csum;						      u->DR = ~csum;
    }								    }
    else							    else
    {								    {
      u->DR = payload[i-2]; // send payload byte		      u->DR = payload[i-2]; // send payload byte
      csum += payload[i-2];					      csum += payload[i-2];
    }								    }
  }								  }
  while (!(u->SR & USART_SR_TC)) { } // wait for TX to finish	  while (!(u->SR & USART_SR_TC)) { } // wait for TX to finish
  u->CR1 &= ~USART_CR1_TE; // disable the transmitter		  u->CR1 &= ~USART_CR1_TE; // disable the transmitter
  u->CR1 |=  USART_CR1_RE; // re-enable the receiver		  u->CR1 |=  USART_CR1_RE; // re-enable the receiver
  // todo: actually spin here until we get a packet back in t	  // todo: actually spin here until we get a packet back in t
}								}

uint8_t dmxl_send_ping(const uint8_t port_idx, const uint8_t 	uint8_t dmxl_send_ping(const uint8_t port_idx, const uint8_t 
{								{
  uint8_t pkt[3];						  uint8_t pkt[3];
  pkt[0] = dmxl_id;						  pkt[0] = dmxl_id;
  pkt[1] = 2; // packet length					  pkt[1] = 2; // packet length
  pkt[2] = 1; // instruction: ping				  pkt[2] = 1; // instruction: ping
  dmxl_tx(port_idx, pkt, sizeof(pkt));				  dmxl_tx(port_idx, pkt, sizeof(pkt));
  return 1; // todo						  return 1; // todo
}								}

static void dmxl_write_data(const uint8_t port_idx, const uin	static void dmxl_write_data(const uint8_t port_idx, const uin
                            const uint8_t data_len, const uin	                            const uint8_t data_len, const uin
                            const uint8_t *data)		                            const uint8_t *data)
{								{
  uint8_t pkt[255];						  uint8_t pkt[255];
  pkt[0] = dmxl_id;						  pkt[0] = dmxl_id;
  pkt[1] = data_len + 3;					  pkt[1] = data_len + 3;
  pkt[2] = 3; // instruction: "write data"			  pkt[2] = 3; // instruction: "write data"
  pkt[3] = start_addr;						  pkt[3] = start_addr;
  for (int i = 0; i < data_len; i++)				  for (int i = 0; i < data_len; i++)
    pkt[4+i] = data[i];						    pkt[4+i] = data[i];
  dmxl_tx(port_idx, pkt, data_len + 4);				  dmxl_tx(port_idx, pkt, data_len + 4);
}								}

static void dmxl_read_data(const uint8_t port_idx, const uint	static void dmxl_read_data(const uint8_t port_idx, const uint
                           const uint8_t data_len, const uint	                           const uint8_t data_len, const uint
{								{
  uint8_t pkt[255];						  uint8_t pkt[255];
  pkt[0] = dmxl_id;						  pkt[0] = dmxl_id;
  pkt[1] = 4; // this packet's "length" is 4			  pkt[1] = 4; // this packet's "length" is 4
  pkt[2] = 2; // instruction: "read data"			  pkt[2] = 2; // instruction: "read data"
  pkt[3] = start_addr;						  pkt[3] = start_addr;
  pkt[4] = data_len;						  pkt[4] = data_len;
  dmxl_tx(port_idx, pkt, 5);					  dmxl_tx(port_idx, pkt, 5);
}								}

void dmxl_process_ring(const uint_fast8_t dmxl_id)		void dmxl_process_ring(const uint_fast8_t dmxl_id)
{								{
  const uint_fast8_t i = dmxl_id; // save typing...		  const uint_fast8_t i = dmxl_id; // save typing...
  while (g_dmxl_ring_rpos[i] != g_dmxl_ring_wpos[i])		  while (g_dmxl_ring_rpos[i] != g_dmxl_ring_wpos[i])
  {								  {
    const uint8_t b = g_dmxl_ring[i][g_dmxl_ring_rpos[i]];	    const uint8_t b = g_dmxl_ring[i][g_dmxl_ring_rpos[i]];
    //printf("dmxl %d received 0x%02x\r\n", i, b);		    //printf("dmxl %d received 0x%02x\r\n", i, b);
    if (++g_dmxl_ring_rpos[i] >= DMXL_RING_LEN)			    if (++g_dmxl_ring_rpos[i] >= DMXL_RING_LEN)
      g_dmxl_ring_rpos[i] = 0; // wrap around			      g_dmxl_ring_rpos[i] = 0; // wrap around
    dmxl_port_t *port = &g_dmxl_ports[i]; // save typing	    dmxl_port_t *port = &g_dmxl_ports[i]; // save typing
    switch (port->parser_state)					    switch (port->parser_state)
    {								    {
      case DMXL_PS_PREAMBLE_0:					      case DMXL_PS_PREAMBLE_0:
        if (b == 0xff)						        if (b == 0xff)
          port->parser_state = DMXL_PS_PREAMBLE_1;		          port->parser_state = DMXL_PS_PREAMBLE_1;
        break;							        break;
      case DMXL_PS_PREAMBLE_1:					      case DMXL_PS_PREAMBLE_1:
        if (b == 0xff)						        if (b == 0xff)
          port->parser_state = DMXL_PS_ID;			          port->parser_state = DMXL_PS_ID;
        else							        else
          port->parser_state = DMXL_PS_PREAMBLE_0;		          port->parser_state = DMXL_PS_PREAMBLE_0;
        break;							        break;
      case DMXL_PS_ID:						      case DMXL_PS_ID:
        port->rx_checksum = b;					        port->rx_checksum = b;
        port->parser_state = DMXL_PS_LENGTH; // ignore ID (al	        port->parser_state = DMXL_PS_LENGTH; // ignore ID (al
        break;							        break;
      case DMXL_PS_LENGTH:					      case DMXL_PS_LENGTH:
        port->rx_pkt_len = b - 2;				        port->rx_pkt_len = b - 2;
        port->rx_checksum += b;					        port->rx_checksum += b;
        port->parser_state = DMXL_PS_ERROR;			        port->parser_state = DMXL_PS_ERROR;
        break;							        break;
      case DMXL_PS_ERROR:					      case DMXL_PS_ERROR:
        handState.dynamixel_error_status[i] = b; // save for  |	        g_state.dynamixel_error_status[i] = b; // save for gl
        port->rx_checksum += b;					        port->rx_checksum += b;
        port->rx_pkt_writepos = 0;				        port->rx_pkt_writepos = 0;
        if (port->rx_pkt_len)					        if (port->rx_pkt_len)
          port->parser_state = DMXL_PS_PARAMETER;		          port->parser_state = DMXL_PS_PARAMETER;
        else							        else
          port->parser_state = DMXL_PS_CHECKSUM;		          port->parser_state = DMXL_PS_CHECKSUM;
        break;							        break;
      case DMXL_PS_PARAMETER:					      case DMXL_PS_PARAMETER:
        port->rx_checksum += b;					        port->rx_checksum += b;
        g_dmxl_rx_pkt[i][port->rx_pkt_writepos] = b;		        g_dmxl_rx_pkt[i][port->rx_pkt_writepos] = b;
        if (port->rx_pkt_writepos == port->rx_pkt_len - 1)	        if (port->rx_pkt_writepos == port->rx_pkt_len - 1)
          port->parser_state = DMXL_PS_CHECKSUM;		          port->parser_state = DMXL_PS_CHECKSUM;
        port->rx_pkt_writepos++;				        port->rx_pkt_writepos++;
        break;							        break;
      case DMXL_PS_CHECKSUM:					      case DMXL_PS_CHECKSUM:
        if (((uint8_t)(~port->rx_checksum)) == b)		        if (((uint8_t)(~port->rx_checksum)) == b)
        {							        {
          /*							          /*
             printf("checksum passed. received %d bytes\r\n",	             printf("checksum passed. received %d bytes\r\n",
             for (int j = 0; j < port->rx_pkt_len; j++)		             for (int j = 0; j < port->rx_pkt_len; j++)
             printf("  0x%02x\r\n", g_dmxl_rx_pkt[i][j]);	             printf("  0x%02x\r\n", g_dmxl_rx_pkt[i][j]);
           */							           */
          switch (port->comms_state)				          switch (port->comms_state)
          {							          {
            case DMXL_CS_POLL_STATE:				            case DMXL_CS_POLL_STATE:
              handState.dynamixel_angles[i] =		      |	              g_state.dynamixel_angles[i] =
                (((uint16_t)g_dmxl_rx_pkt[i][1]) << 8) |	                (((uint16_t)g_dmxl_rx_pkt[i][1]) << 8) |
                (((uint16_t)g_dmxl_rx_pkt[i][0])     ) ;	                (((uint16_t)g_dmxl_rx_pkt[i][0])     ) ;
              //printf("dmxl %d angle = %d\r\n", (int)i, (int |	              //printf("dmxl %d angle = %d\r\n", (int)i, (int
              handState.dynamixel_speeds[i] =		      |	              g_state.dynamixel_speeds[i] =
                (((uint16_t)g_dmxl_rx_pkt[i][3]) << 8) |	                (((uint16_t)g_dmxl_rx_pkt[i][3]) << 8) |
                (((uint16_t)g_dmxl_rx_pkt[i][2])     ) ;	                (((uint16_t)g_dmxl_rx_pkt[i][2])     ) ;
              handState.dynamixel_loads[i] =		      |	              g_state.dynamixel_loads[i] =
                (((uint16_t)g_dmxl_rx_pkt[i][5]) << 8) |	                (((uint16_t)g_dmxl_rx_pkt[i][5]) << 8) |
                (((uint16_t)g_dmxl_rx_pkt[i][4])     ) ;	                (((uint16_t)g_dmxl_rx_pkt[i][4])     ) ;
              handState.dynamixel_voltages[i]     = g_dmxl_rx |	              g_state.dynamixel_voltages[i]     = g_dmxl_rx_p
              handState.dynamixel_temperatures[i] = g_dmxl_rx |	              g_state.dynamixel_temperatures[i] = g_dmxl_rx_p
              break;						              break;
            case DMXL_CS_POLL_DEBRIS:				            case DMXL_CS_POLL_DEBRIS:
              break;						              break;
            default:						            default:
              break;						              break;
          }							          }
        }							        }
        else							        else
          printf("checksum failed: local 0x%02x != received 0	          printf("checksum failed: local 0x%02x != received 0
              (uint8_t)~port->rx_checksum, b);			              (uint8_t)~port->rx_checksum, b);
        port->parser_state = DMXL_PS_PREAMBLE_0;		        port->parser_state = DMXL_PS_PREAMBLE_0;
        port->comms_state = DMXL_CS_IDLE;			        port->comms_state = DMXL_CS_IDLE;
        break;							        break;
      default:							      default:
        printf("woah there partner. unexpected dmxl rx state!	        printf("woah there partner. unexpected dmxl rx state!
        port->parser_state = DMXL_PS_PREAMBLE_0;		        port->parser_state = DMXL_PS_PREAMBLE_0;
        break;							        break;
    }								    }
  }								  }
}								}

void dmxl_process_rings()					void dmxl_process_rings()
{								{
  for (uint_fast8_t i = 0; i < NUM_DMXL; i++)			  for (uint_fast8_t i = 0; i < NUM_DMXL; i++)
    dmxl_process_ring(i);					    dmxl_process_ring(i);
}								}

// See Dynamixel addresses here: http://support.robotis.com/e	// See Dynamixel addresses here: http://support.robotis.com/e
void dmxl_set_led(const uint8_t port_idx, const uint8_t dmxl_	void dmxl_set_led(const uint8_t port_idx, const uint8_t dmxl_
                  const uint8_t enable)				                  const uint8_t enable)
{								{
  uint8_t d = enable ? 1 : 0;					  uint8_t d = enable ? 1 : 0;
  dmxl_write_data(port_idx, dmxl_id, 1, 25, &d); // 25 = LED 	  dmxl_write_data(port_idx, dmxl_id, 1, 25, &d); // 25 = LED 
}								}


void dmxl_set_torque_enable(const uint8_t port_idx, const uin	void dmxl_set_torque_enable(const uint8_t port_idx, const uin
                            const uint8_t enable)		                            const uint8_t enable)
{								{
  uint8_t d = enable ? 1 : 0;					  uint8_t d = enable ? 1 : 0;
  dmxl_write_data(port_idx, dmxl_id, 1, 24, &d);		  dmxl_write_data(port_idx, dmxl_id, 1, 24, &d);
}								}

void dmxl_set_angle_limits(const uint8_t port_idx, const uint	void dmxl_set_angle_limits(const uint8_t port_idx, const uint
                           const uint16_t cw_limit, const uin	                           const uint16_t cw_limit, const uin
{								{
  uint8_t d[4];							  uint8_t d[4];
  d[0] = cw_limit & 0xff;					  d[0] = cw_limit & 0xff;
  d[1] = (cw_limit >> 8) & 0xff;				  d[1] = (cw_limit >> 8) & 0xff;
  d[2] = ccw_limit & 0xff;					  d[2] = ccw_limit & 0xff;
  d[3] = (ccw_limit >> 8) & 0xff;				  d[3] = (ccw_limit >> 8) & 0xff;
  dmxl_write_data(port_idx, dmxl_id, 4, 6, d);			  dmxl_write_data(port_idx, dmxl_id, 4, 6, d);
}								}

void dmxl_set_res_divider(const uint8_t port_idx, const uint8	void dmxl_set_res_divider(const uint8_t port_idx, const uint8
                          const uint8_t res_divider)		                          const uint8_t res_divider)
{								{
  dmxl_write_data(port_idx, dmxl_id, 1, 22, &res_divider);	  dmxl_write_data(port_idx, dmxl_id, 1, 22, &res_divider);
}								}

void dmxl_set_multiturn_offset(const uint8_t port_idx, const 	void dmxl_set_multiturn_offset(const uint8_t port_idx, const 
                               const uint16_t offset)		                               const uint16_t offset)
{								{
  uint8_t d[2];							  uint8_t d[2];
  d[0] = offset & 0xff;						  d[0] = offset & 0xff;
  d[1] = (offset >> 8) & 0xff;					  d[1] = (offset >> 8) & 0xff;
  dmxl_write_data(port_idx, dmxl_id, 2, 20, d);			  dmxl_write_data(port_idx, dmxl_id, 2, 20, d);
}								}

void dmxl_set_speed_dir(const uint8_t port_idx, const uint8_t	void dmxl_set_speed_dir(const uint8_t port_idx, const uint8_t
                        const uint16_t speed, const uint8_t d	                        const uint16_t speed, const uint8_t d
{								{
  uint8_t d[2];							  uint8_t d[2];
  d[0] = speed & 0xff;						  d[0] = speed & 0xff;
  d[1] = ((speed >> 8) & 0x03) | (dir ? 0x04 : 0);		  d[1] = ((speed >> 8) & 0x03) | (dir ? 0x04 : 0);
  dmxl_write_data(port_idx, dmxl_id, 2, 32, d);			  dmxl_write_data(port_idx, dmxl_id, 2, 32, d);
}								}

void dmxl_set_control_mode(const uint8_t port_idx,		void dmxl_set_control_mode(const uint8_t port_idx,
                           const dmxl_control_mode_t control_	                           const dmxl_control_mode_t control_
{								{
  //printf("dmxl_set_control_mode %d %d\r\n", port_idx, (int)	  //printf("dmxl_set_control_mode %d %d\r\n", port_idx, (int)
  if (port_idx >= NUM_DMXL)					  if (port_idx >= NUM_DMXL)
    return;							    return;
  if (control_mode == DMXL_CM_IDLE || control_mode == DMXL_CM	  if (control_mode == DMXL_CM_IDLE || control_mode == DMXL_CM
  {								  {
    dmxl_set_led(port_idx, DMXL_DEFAULT_ID, 0);			    dmxl_set_led(port_idx, DMXL_DEFAULT_ID, 0);
    delay_us(1);						    delay_us(1);
    dmxl_set_torque_enable(port_idx, DMXL_DEFAULT_ID, 0);	    dmxl_set_torque_enable(port_idx, DMXL_DEFAULT_ID, 0);
  }								  }
  else if (control_mode == DMXL_CM_POSITION)			  else if (control_mode == DMXL_CM_POSITION)
  {								  {
    dmxl_set_led(port_idx, DMXL_DEFAULT_ID, 1);			    dmxl_set_led(port_idx, DMXL_DEFAULT_ID, 1);
    delay_us(1);						    delay_us(1);
    dmxl_set_torque_enable(port_idx, DMXL_DEFAULT_ID, 1);	    dmxl_set_torque_enable(port_idx, DMXL_DEFAULT_ID, 1);
    delay_us(1);						    delay_us(1);
    dmxl_set_angle_limits(port_idx, DMXL_DEFAULT_ID, 4095, 40	    dmxl_set_angle_limits(port_idx, DMXL_DEFAULT_ID, 4095, 40
    // http://support.robotis.com/en/product/dynamixel/mx_ser	    // http://support.robotis.com/en/product/dynamixel/mx_ser
    if (divider_is_sent[port_idx] == 0) {			    if (divider_is_sent[port_idx] == 0) {
      delay_us(1);						      delay_us(1);
      dmxl_set_res_divider(port_idx, DMXL_DEFAULT_ID, 4);	      dmxl_set_res_divider(port_idx, DMXL_DEFAULT_ID, 4);
      delay_us(1);						      delay_us(1);
      dmxl_set_multiturn_offset(port_idx, DMXL_DEFAULT_ID, 13	      dmxl_set_multiturn_offset(port_idx, DMXL_DEFAULT_ID, 13
      divider_is_sent[port_idx] = 1;				      divider_is_sent[port_idx] = 1;
    }								    }
  }								  }
  dmxl_control_mode = control_mode;				  dmxl_control_mode = control_mode;
}								}

void dmxl_set_control_target(const uint8_t port_idx,		void dmxl_set_control_target(const uint8_t port_idx,
                             const uint16_t target)		                             const uint16_t target)
{								{
  //printf("dmxl_set_control_target %d %d\r\n", port_idx, (in	  //printf("dmxl_set_control_target %d %d\r\n", port_idx, (in
  if (port_idx >= NUM_DMXL)					  if (port_idx >= NUM_DMXL)
    return;							    return;
  uint8_t d[2];							  uint8_t d[2];
  d[0] = target & 0xff;						  d[0] = target & 0xff;
  d[1] = (target >> 8) & 0xff;					  d[1] = (target >> 8) & 0xff;
  uint8_t start_addr = 30;  // position control			  uint8_t start_addr = 30;  // position control
  if (dmxl_control_mode == DMXL_CM_VELOCITY) {			  if (dmxl_control_mode == DMXL_CM_VELOCITY) {
    start_addr = 32; // velocity control			    start_addr = 32; // velocity control
  }								  }
  dmxl_write_data(port_idx, DMXL_DEFAULT_ID, 2, start_addr, d	  dmxl_write_data(port_idx, DMXL_DEFAULT_ID, 2, start_addr, d
}								}

void dmxl_set_all_control_targets(const uint16_t *targets)	void dmxl_set_all_control_targets(const uint16_t *targets)
{								{
  // set all control targets simultaneously			  // set all control targets simultaneously
  static uint8_t pkts[NUM_DMXL][12];				  static uint8_t pkts[NUM_DMXL][12];
  for (int i = 0; i < NUM_DMXL; i++)				  for (int i = 0; i < NUM_DMXL; i++)
  {								  {
    USART_TypeDef *u = g_dmxl_ports[i].uart;			    USART_TypeDef *u = g_dmxl_ports[i].uart;
    u->CR1 &= ~USART_CR1_RE; // disable the receiver during t	    u->CR1 &= ~USART_CR1_RE; // disable the receiver during t
    u->CR1 |=  USART_CR1_TE; // enable the transmitter		    u->CR1 |=  USART_CR1_TE; // enable the transmitter
    pkts[i][0] = 0xff;						    pkts[i][0] = 0xff;
    pkts[i][1] = 0xff;						    pkts[i][1] = 0xff;
    pkts[i][2] = DMXL_DEFAULT_ID;				    pkts[i][2] = DMXL_DEFAULT_ID;
    pkts[i][3] = 5; // write 2 bytes + 3 byte overhead		    pkts[i][3] = 5; // write 2 bytes + 3 byte overhead
    pkts[i][4] = 3; // instruction: "write data"		    pkts[i][4] = 3; // instruction: "write data"
    if (dmxl_control_mode == DMXL_CM_VELOCITY) {		    if (dmxl_control_mode == DMXL_CM_VELOCITY) {
      pkts[i][5] = 32; // start address: control target (velo	      pkts[i][5] = 32; // start address: control target (velo
    } else {							    } else {
      pkts[i][5] = 30; // start address: control target (posi	      pkts[i][5] = 30; // start address: control target (posi
    }								    }
    pkts[i][6] = targets[i] & 0xff; // LSB of control target	    pkts[i][6] = targets[i] & 0xff; // LSB of control target
    pkts[i][7] = (targets[i] >> 8) & 0xff; // MSB of control 	    pkts[i][7] = (targets[i] >> 8) & 0xff; // MSB of control 
    pkts[i][8] = 0; // checksum					    pkts[i][8] = 0; // checksum
    for (int j = 2; j < 8; j++)					    for (int j = 2; j < 8; j++)
      pkts[i][8] += pkts[i][j];					      pkts[i][8] += pkts[i][j];
    pkts[i][8] = ~pkts[i][8]; // invert checksum		    pkts[i][8] = ~pkts[i][8]; // invert checksum
  }								  }
  for (int j = 0; j < 9; j++)					  for (int j = 0; j < 9; j++)
  {								  {
    for (int i = 0; i < NUM_DMXL; i++)				    for (int i = 0; i < NUM_DMXL; i++)
    {								    {
      USART_TypeDef *u = g_dmxl_ports[i].uart;			      USART_TypeDef *u = g_dmxl_ports[i].uart;
      while (!(u->SR & USART_SR_TXE)) { } // wait for tx buff	      while (!(u->SR & USART_SR_TXE)) { } // wait for tx buff
      u->DR = pkts[i][j];					      u->DR = pkts[i][j];
    }								    }
  }								  }
  for (int i = 0; i < NUM_DMXL; i++)				  for (int i = 0; i < NUM_DMXL; i++)
  {								  {
    USART_TypeDef *u = g_dmxl_ports[i].uart;			    USART_TypeDef *u = g_dmxl_ports[i].uart;
    while (!(u->SR & USART_SR_TC)) { } // wait for last TX to	    while (!(u->SR & USART_SR_TC)) { } // wait for last TX to
    u->CR1 &= ~USART_CR1_TE; // disable the transmitter		    u->CR1 &= ~USART_CR1_TE; // disable the transmitter
    u->CR1 |=  USART_CR1_RE; // re-enable the receiver		    u->CR1 |=  USART_CR1_RE; // re-enable the receiver
  }								  }
}								}

void dmxl_poll()						void dmxl_poll()
{								{
  // spin through and poll all their angles, velocities, curr	  // spin through and poll all their angles, velocities, curr
  // voltages, temperatures, etc.				  // voltages, temperatures, etc.
  for (uint_fast8_t i = 0; i < NUM_DMXL; i++)			  for (uint_fast8_t i = 0; i < NUM_DMXL; i++)
  {								  {
    g_dmxl_ports[i].comms_state = DMXL_CS_POLL_STATE;		    g_dmxl_ports[i].comms_state = DMXL_CS_POLL_STATE;
    dmxl_read_data(i, DMXL_DEFAULT_ID, 8, 36);			    dmxl_read_data(i, DMXL_DEFAULT_ID, 8, 36);
  }								  }
  volatile uint32_t t_start = SYSTIME;				  volatile uint32_t t_start = SYSTIME;
  while (SYSTIME - t_start < 10000)				  while (SYSTIME - t_start < 10000)
  {								  {
    dmxl_process_rings();					    dmxl_process_rings();
    // also spin around the ethernet rings here? probably not	    // also spin around the ethernet rings here? probably not
    int all_done = 1;						    int all_done = 1;
    for (uint_fast8_t i = 0; i < NUM_DMXL; i++)			    for (uint_fast8_t i = 0; i < NUM_DMXL; i++)
      if (g_dmxl_ports[i].comms_state == DMXL_CS_POLL_STATE)	      if (g_dmxl_ports[i].comms_state == DMXL_CS_POLL_STATE)
        all_done = 0;						        all_done = 0;
    if (all_done)						    if (all_done)
      break;							      break;
  }								  }
  // set the comms state to "idle" even if we didn't hear bac	  // set the comms state to "idle" even if we didn't hear bac
  for (uint_fast8_t i = 0; i < NUM_DMXL; i++)			  for (uint_fast8_t i = 0; i < NUM_DMXL; i++)
    g_dmxl_ports[i].comms_state = DMXL_CS_IDLE;			    g_dmxl_ports[i].comms_state = DMXL_CS_IDLE;
}								}

void dmxl_poll_nonblocking_tick(const uint8_t dmxl_port)	void dmxl_poll_nonblocking_tick(const uint8_t dmxl_port)
{								{
  if (dmxl_port >= NUM_DMXL)					  if (dmxl_port >= NUM_DMXL)
    return; // let's not corrupt memory.			    return; // let's not corrupt memory.
  dmxl_async_poll_state_t *ps = &dmxl_poll_states[dmxl_port];	  dmxl_async_poll_state_t *ps = &dmxl_poll_states[dmxl_port];
  dmxl_port_t *dp = &g_dmxl_ports[dmxl_port];			  dmxl_port_t *dp = &g_dmxl_ports[dmxl_port];
  USART_TypeDef *u = dp->uart;					  USART_TypeDef *u = dp->uart;
  static uint8_t dmxl_txbuf[NUM_DMXL][256];			  static uint8_t dmxl_txbuf[NUM_DMXL][256];
  static uint8_t dmxl_txbuf_readpos[NUM_DMXL] = {0};		  static uint8_t dmxl_txbuf_readpos[NUM_DMXL] = {0};
  static uint32_t dmxl_rx_start_time[NUM_DMXL] = {0};		  static uint32_t dmxl_rx_start_time[NUM_DMXL] = {0};
  switch (*ps)							  switch (*ps)
  {								  {
    case DPS_DONE: // poll start				    case DPS_DONE: // poll start
      dmxl_rx_start_time[dmxl_port] = SYSTIME;			      dmxl_rx_start_time[dmxl_port] = SYSTIME;
      *ps = DPS_WAIT; // give any outbound command some time 	      *ps = DPS_WAIT; // give any outbound command some time 
      break;							      break;
    case DPS_WAIT:						    case DPS_WAIT:
      if (SYSTIME - dmxl_rx_start_time[dmxl_port] > 5000)	      if (SYSTIME - dmxl_rx_start_time[dmxl_port] > 5000)
      {								      {
        u->CR1 &= ~USART_CR1_RE; // disable the receiver duri	        u->CR1 &= ~USART_CR1_RE; // disable the receiver duri
        u->CR1 |=  USART_CR1_TE; // enable the transmitter	        u->CR1 |=  USART_CR1_TE; // enable the transmitter
        dmxl_txbuf[dmxl_port][0] = 0xff; // header		        dmxl_txbuf[dmxl_port][0] = 0xff; // header
        dmxl_txbuf[dmxl_port][1] = 0xff; // more header		        dmxl_txbuf[dmxl_port][1] = 0xff; // more header
        dmxl_txbuf[dmxl_port][2] = DMXL_DEFAULT_ID;		        dmxl_txbuf[dmxl_port][2] = DMXL_DEFAULT_ID;
        dmxl_txbuf[dmxl_port][3] = 4;  // packet length = 4	        dmxl_txbuf[dmxl_port][3] = 4;  // packet length = 4
        dmxl_txbuf[dmxl_port][4] = 2;  // instruction: "read 	        dmxl_txbuf[dmxl_port][4] = 2;  // instruction: "read 
        dmxl_txbuf[dmxl_port][5] = 36; // start address		        dmxl_txbuf[dmxl_port][5] = 36; // start address
        dmxl_txbuf[dmxl_port][6] = 8;  // number of bytes to 	        dmxl_txbuf[dmxl_port][6] = 8;  // number of bytes to 
        uint8_t csum = 0;					        uint8_t csum = 0;
        for (int i = 2; i < 7; i++)				        for (int i = 2; i < 7; i++)
          csum += dmxl_txbuf[dmxl_port][i];			          csum += dmxl_txbuf[dmxl_port][i];
        dmxl_txbuf[dmxl_port][7] = ~csum;			        dmxl_txbuf[dmxl_port][7] = ~csum;
        u->DR; // read any garbage on the RX register		        u->DR; // read any garbage on the RX register
        u->DR = dmxl_txbuf[dmxl_port][0]; // kick it off	        u->DR = dmxl_txbuf[dmxl_port][0]; // kick it off
        dmxl_txbuf_readpos[dmxl_port] = 0;			        dmxl_txbuf_readpos[dmxl_port] = 0;
        *ps = DPS_POLL_TX;					        *ps = DPS_POLL_TX;
      }								      }
      break;							      break;
    case DPS_POLL_TX:						    case DPS_POLL_TX:
      if (u->SR & USART_SR_TXE) // is there room in the TX bu	      if (u->SR & USART_SR_TXE) // is there room in the TX bu
      {								      {
        if (dmxl_txbuf_readpos[dmxl_port] < 7)			        if (dmxl_txbuf_readpos[dmxl_port] < 7)
        {							        {
          dmxl_txbuf_readpos[dmxl_port]++;			          dmxl_txbuf_readpos[dmxl_port]++;
          u->DR = dmxl_txbuf[dmxl_port][dmxl_txbuf_readpos[dm	          u->DR = dmxl_txbuf[dmxl_port][dmxl_txbuf_readpos[dm
        }							        }
        else if (u->SR & USART_SR_TC) // last byte must fully	        else if (u->SR & USART_SR_TC) // last byte must fully
        {							        {
          u->CR1 &= ~USART_CR1_TE; // disable the transmitter	          u->CR1 &= ~USART_CR1_TE; // disable the transmitter
          u->CR1 |=  USART_CR1_RE; // re-enable the transmitt	          u->CR1 |=  USART_CR1_RE; // re-enable the transmitt
          dmxl_rx_start_time[dmxl_port] = SYSTIME;		          dmxl_rx_start_time[dmxl_port] = SYSTIME;
          g_dmxl_ports[dmxl_port].comms_state = DMXL_CS_POLL_	          g_dmxl_ports[dmxl_port].comms_state = DMXL_CS_POLL_
          *ps = DPS_POLL_RX;					          *ps = DPS_POLL_RX;
        }							        }
      }								      }
      break;							      break;
    case DPS_POLL_RX:						    case DPS_POLL_RX:
      dmxl_process_ring(dmxl_port);				      dmxl_process_ring(dmxl_port);
      if (g_dmxl_ports[dmxl_port].comms_state != DMXL_CS_POLL	      if (g_dmxl_ports[dmxl_port].comms_state != DMXL_CS_POLL
        *ps = DPS_DONE; // hooray, we received a full state m	        *ps = DPS_DONE; // hooray, we received a full state m
      if (SYSTIME - dmxl_rx_start_time[dmxl_port] > 10000) //	      if (SYSTIME - dmxl_rx_start_time[dmxl_port] > 10000) //
        *ps = DPS_DONE; // time to give up. gotta know when t	        *ps = DPS_DONE; // time to give up. gotta know when t
      break;							      break;
    default:							    default:
      *ps = DPS_DONE; // shouldn't get here			      *ps = DPS_DONE; // shouldn't get here
      break;							      break;
  }								  }
}								}

bool dmxl_all_available()					bool dmxl_all_available()
{								{
  for (int i = 0; i < NUM_DMXL; i++)				  for (int i = 0; i < NUM_DMXL; i++)
    if (dmxl_poll_states[i] != DPS_DONE)			    if (dmxl_poll_states[i] != DPS_DONE)
      return false;						      return false;
  return true;							  return true;
}								}
diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/dmxl.h /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/dmxl.h
#ifndef DMXL_H							#ifndef DMXL_H
#define DMXL_H							#define DMXL_H

#include <stdint.h>						#include <stdint.h>
#include <stdbool.h>					      <
#include <stdio.h>					      <
							      <
#include "./stm32/stm32f4xx.h"				      <
#include "state.h"					      <
#include "systime.h"					      <
#include "delay.h"					      <
#include "async_poll.h"						#include "async_poll.h"
							      >	#include <stdbool.h>

#define NUM_DMXL 4						#define NUM_DMXL 4
#define DMXL_DEFAULT_ID 1					#define DMXL_DEFAULT_ID 1

typedef enum							typedef enum
{								{
  DMXL_CM_IDLE     = 0,						  DMXL_CM_IDLE     = 0,
  DMXL_CM_VELOCITY = 1,						  DMXL_CM_VELOCITY = 1,
  DMXL_CM_POSITION = 2						  DMXL_CM_POSITION = 2
} dmxl_control_mode_t;						} dmxl_control_mode_t;

void dmxl_init();						void dmxl_init();
void dmxl_process_rings();					void dmxl_process_rings();
void dmxl_process_ring(const uint_fast8_t dmxl_id);		void dmxl_process_ring(const uint_fast8_t dmxl_id);
uint8_t dmxl_ping(const uint8_t port_idx, const uint8_t dmxl_	uint8_t dmxl_ping(const uint8_t port_idx, const uint8_t dmxl_

void dmxl_set_torque_enable(const uint8_t port_idx, const uin	void dmxl_set_torque_enable(const uint8_t port_idx, const uin
                            const uint8_t enable);		                            const uint8_t enable);
void dmxl_set_led(const uint8_t port_idx, const uint8_t dmxl_	void dmxl_set_led(const uint8_t port_idx, const uint8_t dmxl_
                  const uint8_t enable);			                  const uint8_t enable);
void dmxl_set_angle_limits(const uint8_t port_idx, const uint	void dmxl_set_angle_limits(const uint8_t port_idx, const uint
                           const uint16_t cw_limit, const uin	                           const uint16_t cw_limit, const uin
void dmxl_set_res_divider(const uint8_t port_idx, const uint8	void dmxl_set_res_divider(const uint8_t port_idx, const uint8
                          const uint8_t res_divider);		                          const uint8_t res_divider);
void dmxl_set_multiturn_offset(const uint8_t port_idx, const 	void dmxl_set_multiturn_offset(const uint8_t port_idx, const 
                               const uint16_t offset);		                               const uint16_t offset);
void dmxl_set_speed_dir(const uint8_t port_idx, const uint8_t	void dmxl_set_speed_dir(const uint8_t port_idx, const uint8_t
                        const uint16_t speed, const uint8_t d	                        const uint16_t speed, const uint8_t d
void dmxl_set_control_mode(const uint8_t port_idx, 		void dmxl_set_control_mode(const uint8_t port_idx, 
                           const dmxl_control_mode_t control_	                           const dmxl_control_mode_t control_
void dmxl_set_control_target(const uint8_t port_idx, 		void dmxl_set_control_target(const uint8_t port_idx, 
                             const uint16_t target);		                             const uint16_t target);
void dmxl_set_all_control_targets(const uint16_t *targets);	void dmxl_set_all_control_targets(const uint16_t *targets);

void dmxl_poll();						void dmxl_poll();
void dmxl_poll_nonblocking_tick(const uint8_t dmxl_port);	void dmxl_poll_nonblocking_tick(const uint8_t dmxl_port);

typedef enum 							typedef enum 
{ 								{ 
  DPS_WAIT,							  DPS_WAIT,
  DPS_POLL_TX,							  DPS_POLL_TX,
  DPS_POLL_RX,							  DPS_POLL_RX,
  DPS_DONE = ASYNC_POLL_DONE					  DPS_DONE = ASYNC_POLL_DONE
} dmxl_async_poll_state_t;					} dmxl_async_poll_state_t;
extern dmxl_async_poll_state_t dmxl_poll_states[NUM_DMXL];	extern dmxl_async_poll_state_t dmxl_poll_states[NUM_DMXL];

bool dmxl_all_available();					bool dmxl_all_available();

void dmxl_set_status_return_levels();				void dmxl_set_status_return_levels();
void dmxl_set_baud_rates();					void dmxl_set_baud_rates();

#endif 								#endif 
diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/enc.c /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/enc.c
#include "enc.h"						#include "enc.h"
							      >	#include "stm32f4xx.h"
							      >	#include <stdio.h>
							      >	#include "pin.h"
							      >	#include "state.h"
							      >	#include "systime.h"
							      >	#include "error.h"
							      >
							      >	/////////////////////////////////////////////////////////////
							      >	// encoder daisy-chain setup
							      >	//
							      >	// spi4 cs   = pe11, af 5
							      >	// spi4 sclk = pe12, af 5
							      >	// spi4 miso = pe13, af 5
							      >	// spi4 mosi = pe14, af 5
							      >
							      >	#define PORTE_ENC_CS   11
							      >	#define PORTE_ENC_SCLK 12
							      >	#define PORTE_ENC_MISO 13
							      >	#define PORTE_ENC_MOSI 14
							      >
							      >	#define TRUE 1
							      >	#define FALSE 0
							      >	// The number of times we get the same reading before we ligh
							      >	// LED
							      >	static const uint8_t LIGHT_LED_THRESHOLD = 100;

// GLOBAL ALL FILES VARIABLE				      |	enc_async_poll_state_t enc_poll_state = { EPS_DONE };
enc_async_poll_state_t enc_poll_state[3] = {STATE_WAIT, STATE <

void encInit()						      |	void enc_init()
{								{
  // initializing encoders state			      |	  printf("enc_init()\r\n");
							      >	  RCC->APB2ENR |= RCC_APB2ENR_SPI4EN; // turn on SPI4
							      >
							      >	  pin_set_output(GPIOE, PORTE_ENC_CS);
							      >	  pin_set_output_level(GPIOE, PORTE_ENC_CS, 1);
							      >	  pin_set_alternate_function(GPIOE, PORTE_ENC_SCLK, 5);
							      >	  pin_set_alternate_function(GPIOE, PORTE_ENC_MISO, 5);
							      >	  pin_set_alternate_function(GPIOE, PORTE_ENC_MOSI, 5);
							      >
							      >	  // spi4 is running from a 84 MHz pclk. set it up with
							      >	  // sclk = pclk/128 to be super slow for now.
							      >	  SPI4->CR1 = SPI_CR1_DFF  | // 16-bit mode
							      >	              SPI_CR1_BR_2 |
							      >	              SPI_CR1_BR_1 |
							      >	              SPI_CR1_MSTR | // master mode
							      >	              SPI_CR1_CPHA | // cpha=1, cpol=0 for AS5048A
							      >	              SPI_CR1_SSM  | // software slave-select mode
							      >	              SPI_CR1_SSI  |
							      >	              SPI_CR1_SPE;
							      >
							      >	  enc_poll(); // first one will be garbage
							      >	  enc_poll(); // and the second one
							      >	}
							      >
							      >	/*
							      >	 * Blocking call to get encoder data for all 3 encoders
							      >	 */
							      >	void enc_poll()
							      >	{
							      >	  GPIOE->BSRRH = 1 << PORTE_ENC_CS; // assert (pull down) CS
							      >	  for (volatile int i = 0; i < 10; i++) { } // needs at least
							      >	  SPI4->DR; // clear the rx data register in case it has some
  for (int i = 0; i < NUM_ENC; i++)				  for (int i = 0; i < NUM_ENC; i++)
  {								  {
    handState.encoders[i] = 0;				      |	    SPI4->DR = 0xffff;
							      >	    while (!(SPI4->SR & SPI_SR_TXE)) { } // Wait for transmit
							      >	    while (!(SPI4->SR & SPI_SR_RXNE)) { } // Wait for recieve
							      >	    g_state.encoders[NUM_ENC-1-i] = SPI4->DR & 0x3fff;  // Id
  }								  }
							      >	  for (volatile int i = 0; i < 1; i++) { } // needs at least 
							      >	  GPIOE->BSRRL = 1 << PORTE_ENC_CS; // de-assert (pull up) CS
							      >	  /*
							      >	  printf("       enc: %06d  %06d  %06d\r\n",
							      >	         g_state.encoders[0],
							      >	         g_state.encoders[1],
							      >	         g_state.encoders[2]);
							      >	  */
}								}

/*							      |
void enc_poll_nonblocking_tick(const uint8_t encoderNumber)   |	void enc_poll_nonblocking_tick(const uint8_t bogus __attribut
  Description: Updates the state machine, which has 3 states: <
      ENCODER_STATE_SET_REGISTER: set the right encoder regis <
      ter						      <
      ENCODER_STATE_READ_VALUES: read encoder values	      <
      ENCODER_STATE_WAIT: skips the encoder while other state <
      machines are not finished				      <
							      <
  Returns: void						      <
  							      <
  Encoders connections:					      <
    0 -> Port I2C1					      <
    1 -> Port SPI					      <
    2 -> Port I2C3					      <
*/							      <
void enc_poll_nonblocking_tick(const uint8_t encoderNumber)   <
{								{
  enc_async_poll_state_t* state = (enc_async_poll_state_t*)&( |	  static uint_fast8_t enc_poll_state_word_idx = 0;
  switch(*state)					      |	  static uint32_t enc_poll_state_start_time_us = 0;
							      >	  static uint8_t all_the_same = TRUE;
							      >	  static uint8_t all_the_same_count = 0;
							      >	  static uint8_t same_count[3] = {0};
							      >	  switch(enc_poll_state)
  {								  {
    case ENCODER_STATE_SET_REGISTER:			      |	    case EPS_DONE: // this is the start state
      if (setEncoderRegister(encoderNumber, AS5048B_ANGLLSB_R |	      GPIOE->BSRRH = 1 << PORTE_ENC_CS; // assert (pull down)
        *state = ENCODER_STATE_READ_VALUES;		      |	      enc_poll_state_start_time_us = SYSTIME;
							      >	      enc_poll_state = EPS_CS_ASSERTED;
							      >	      break;
							      >	    case EPS_CS_ASSERTED:
							      >	      if (SYSTIME - enc_poll_state_start_time_us > 2)
							      >	      {
							      >	        all_the_same = TRUE;
							      >	        SPI4->DR; // clear the rx data register in case it ha
							      >	        enc_poll_state_word_idx = 0;
							      >	        SPI4->DR = 0xffff;
							      >	        enc_poll_state = EPS_SPI_TXRX;
							      >	      }
      break;							      break;
    case ENCODER_STATE_READ_VALUES:			      |	    case EPS_SPI_TXRX:
      if(readEncoderValues(encoderNumber, SPI_TIMEOUT));      |	      if ((SPI4->SR & SPI_SR_TXE) && (SPI4->SR & SPI_SR_RXNE)
        *state = ENCODER_STATE_WAIT;			      |	      {
							      >	        uint16_t readValue =  SPI4->DR & 0x3fff;
							      >
							      >	        if (readValue == g_state.encoders[NUM_ENC-1-enc_poll_
							      >	          same_count[NUM_ENC-1-enc_poll_state_word_idx]++;
							      >	        } else {
							      >	          same_count[NUM_ENC-1-enc_poll_state_word_idx] = 0;
							      >	          all_the_same = FALSE;
							      >	        }
							      >
							      >	        g_state.encoders[NUM_ENC-1-(enc_poll_state_word_idx++
							      >	        if (enc_poll_state_word_idx >= NUM_ENC)
							      >	        {
							      >	          enc_poll_state = EPS_SPI_TXRX_DONE;
							      >	          enc_poll_state_start_time_us = SYSTIME;
							      >	        }
							      >	        else {
							      >	          SPI4->DR = 0xffff;
							      >	        }
							      >	      }
      break;							      break;
    case ENCODER_STATE_WAIT:				      |	    case EPS_SPI_TXRX_DONE:
							      >	      if (SYSTIME - enc_poll_state_start_time_us > 2)
							      >	      {
							      >	        if (all_the_same) {
							      >	          if (all_the_same_count < LIGHT_LED_THRESHOLD) {
							      >	            all_the_same_count++;
							      >	          }
							      >	        } else {
							      >	          all_the_same_count = 0;
							      >	        }
							      >	        if (all_the_same_count >= LIGHT_LED_THRESHOLD) {
							      >	          err_set(ERR_ENC_ALL_STUCK);
							      >	        } else {
							      >	          err_unset(ERR_ENC_ALL_STUCK);
							      >	        }
							      >
							      >	        if (same_count[0] >= LIGHT_LED_THRESHOLD) {
							      >	          err_set(ERR_ENC_1_STUCK);
							      >	        } else {
							      >	          err_unset(ERR_ENC_1_STUCK);
							      >	        }
							      >	        if (same_count[1] >= LIGHT_LED_THRESHOLD) {
							      >	          err_set(ERR_ENC_2_STUCK);
							      >	        } else {
							      >	          err_unset(ERR_ENC_2_STUCK);
							      >	        }
							      >	        if (same_count[2] >= LIGHT_LED_THRESHOLD) {
							      >	          err_set(ERR_ENC_3_STUCK);
							      >	        } else {
							      >	          err_unset(ERR_ENC_3_STUCK);
							      >	        }
							      >
							      >
							      >	        GPIOE->BSRRL = 1 << PORTE_ENC_CS; // de-assert (pull 
							      >	        enc_poll_state = EPS_DONE;
							      >	      }
      break;							      break;
    default:							    default:
      *state = ENCODER_STATE_WAIT;			      |	      enc_poll_state = EPS_DONE; // shouldn't get here
      break;							      break;
  }								  }
}								}

uint8_t setEncoderRegister(uint8_t encoderNumber, uint8_t enc <
{							      <
  uint8_t result = 0;					      <
  switch ((uint32_t) handPorts.encoder[encoderNumber])	      <
  {							      <
    case I2C1_BASE:					      <
      result = writeRegisterI2C(handPorts.encoder[encoderNumb <
    break;						      <
    case I2C3_BASE:					      <
      result = writeRegisterI2C(handPorts.encoder[encoderNumb <
    break;						      <
    case SPI1_BASE:					      <
      result = writeRegisterSPI(handPorts.encoder[encoderNumb <
    break;						      <
  }							      <
  return result;					      <
}							      <
							      <
uint8_t readEncoderValues(uint8_t encoderNumber, int timeout) <
{							      <
  uint8_t result = 0;					      <
  uint8_t valueRead[2];					      <
  switch ((uint32_t) handPorts.encoder[encoderNumber])	      <
  {							      <
    case I2C1_BASE:					      <
      result = readBytesI2C(handPorts.encoder[encoderNumber], <
    break;						      <
    case I2C3_BASE:					      <
      result = readBytesI2C(handPorts.encoder[encoderNumber], <
    break;						      <
    case SPI1_BASE:					      <
      result = readBytesSPI(handPorts.encoder[encoderNumber], <
    break;						      <
  }							      <
  handState.encoders[encoderNumber] = (((uint16_t) valueRead[ <
  return result;					      <
}							      <diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/enc.h /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/enc.h
#ifndef ENC_H							#ifndef ENC_H
#define ENC_H							#define ENC_H

#include "i2cFunc.h"					      <
#include "spiFunc.h"					      <
							      <
#include <reflex.h>					      <
#include <stdint.h>						#include <stdint.h>
#include "async_poll.h"						#include "async_poll.h"
#include "./stm32/stm32f4xx.h"				      <
#include <stdio.h>					      <
#include "pin.h"					      <
#include "state.h"					      <
#include "systime.h"					      <
#include "error.h"					      <
#include "leds.h"   //rmelo19, for debugging		      <
#include "ports.h"					      <
							      <
// FOR SPI						      <
#define PORTA_BRIDGE0_CS            4			      <
							      <
// ERRORS						      <
#define LIGHT_LED_THRESHOLD         100 // The number of time <

// ARDUINO TESTS					      |	void enc_init();
#define ARDUINO_7BIT_ADDR 0x20 				      |	void enc_poll();
							      |	void enc_poll_nonblocking_tick(const uint8_t bogus __attribut
// AS5048 ADDRESSES					      <
#define AS5048_7BIT_ADDRESS         0x40 // 0b10000 + ( A1 &  <
#define AS5048_7BIT_ADDRESS_SPI     0x40 //0x42 // 0b1000010  <
#define AS5048_ADDRESSS_READ        0x81 // 0b01000001	      <
#define AS5048_ADDRESS_WRITE        0x80 // 0b01000000	      <
#define AS5048B_ANGLMSB_REG         0xFE // bits 0..7	      <
#define AS5048B_ANGLLSB_REG         0xFF // bits 0..5	      <
							      <
// EASY TO READ						      <
#define TRUE                        1			      <
#define FALSE                       0			      <
#define ON                          1			      <
#define OFF                         0			      <

typedef enum 							typedef enum 
{ 								{ 
  ENCODER_STATE_SET_REGISTER = 0,			      |	  EPS_CS_ASSERTED = 0,
  ENCODER_STATE_READ_VALUES,				      |	  EPS_SPI_TXRX,
  ENCODER_STATE_WAIT = ASYNC_POLL_DONE			      |	  EPS_SPI_TXRX_DONE,
							      >	  EPS_DONE = ASYNC_POLL_DONE
} enc_async_poll_state_t;					} enc_async_poll_state_t;
							      >	extern enc_async_poll_state_t enc_poll_state;

extern enc_async_poll_state_t enc_poll_state[3];	      |	#define NUM_ENC 3
							      <
uint8_t setEncoderRegister(uint8_t encoderNumber, uint8_t enc <
uint8_t readEncoderValues(uint8_t encoderNumber, int timeout) <
							      <
void encInit();						      <
void enc_poll();					      <
void enc_poll_nonblocking_tick(const uint8_t encoderNumber);  <
							      <
							      <

#endif								#endif

Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: enc (without different encoder state machines).c
diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/enet.c /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/enet.c
#include "enet.h"						#include "enet.h"
							      >	#include "stm32f4xx.h"
							      >	#include <stdio.h>
							      >	#include <string.h>
							      >	#include "dmxl.h"
							      >	#include "error.h"
							      >	#include "state.h"
							      >	#include "systime.h"
							      >	#include "delay.h"
							      >
							      >	// declare the pin numbers
							      >	#define PORTA_ETH_REFCLK 1
							      >	#define PORTA_ETH_MDIO   2
							      >	#define PORTA_ETH_CRSDV  7
							      >	#define PORTB_ETH_TXEN   11
							      >	#define PORTB_ETH_TXD0   12
							      >	#define PORTB_ETH_TXD1   13
							      >	#define PORTB_PHY_RESET  14
							      >	#define PORTC_ETH_MDC    1
							      >	#define PORTC_ETH_RXD0   4
							      >	#define PORTC_ETH_RXD1   5
							      >
							      >	// address is hard-wired on board using internal chip pullups
							      >	#define ENET_PHY_ADDR 0x01
							      >
							      >	#define ETH_NBUF 2048
							      >	#define ETH_DMA_NRXD 16
							      >	#define ETH_DMA_NTXD  4
							      >
							      >	typedef struct
							      >	{
							      >	  uint32_t des0;
							      >	  uint32_t des1;
							      >	  uint32_t des2;
							      >	  uint32_t des3;
							      >	} eth_dma_desc_t;
							      >
							      >	#define ALIGN4 __attribute__((aligned(4)));

static volatile eth_dma_desc_t g_eth_dma_rx_desc[ETH_DMA_NRXD	static volatile eth_dma_desc_t g_eth_dma_rx_desc[ETH_DMA_NRXD
static volatile eth_dma_desc_t g_eth_dma_tx_desc[ETH_DMA_NTXD	static volatile eth_dma_desc_t g_eth_dma_tx_desc[ETH_DMA_NTXD
static volatile uint8_t g_eth_dma_rx_buf[ETH_DMA_NRXD][ETH_NB	static volatile uint8_t g_eth_dma_rx_buf[ETH_DMA_NRXD][ETH_NB
static volatile uint8_t g_eth_dma_tx_buf[ETH_DMA_NTXD][ETH_NB	static volatile uint8_t g_eth_dma_tx_buf[ETH_DMA_NTXD][ETH_NB
static volatile eth_dma_desc_t *g_eth_dma_rx_next_desc = &g_e	static volatile eth_dma_desc_t *g_eth_dma_rx_next_desc = &g_e
static volatile eth_dma_desc_t *g_eth_dma_tx_next_desc = &g_e	static volatile eth_dma_desc_t *g_eth_dma_tx_next_desc = &g_e

							      >	#define ETH_RAM_RXPOOL_LEN  16384
							      >	#define ETH_RAM_RXPOOL_NPTR   128
static volatile uint8_t  g_eth_rxpool[ETH_RAM_RXPOOL_LEN] ALI	static volatile uint8_t  g_eth_rxpool[ETH_RAM_RXPOOL_LEN] ALI
static volatile uint16_t g_eth_rxpool_wpos = 0;			static volatile uint16_t g_eth_rxpool_wpos = 0;
static volatile uint8_t *g_eth_rxpool_start[ETH_RAM_RXPOOL_NP	static volatile uint8_t *g_eth_rxpool_start[ETH_RAM_RXPOOL_NP
static volatile uint16_t g_eth_rxpool_len[ETH_RAM_RXPOOL_NPTR	static volatile uint16_t g_eth_rxpool_len[ETH_RAM_RXPOOL_NPTR
static volatile uint16_t g_eth_rxpool_ptrs_wpos = 0;		static volatile uint16_t g_eth_rxpool_ptrs_wpos = 0;
static volatile uint16_t g_eth_rxpool_ptrs_rpos = 0;		static volatile uint16_t g_eth_rxpool_ptrs_rpos = 0;

							      >	/////////////////////////////////////////////////////////////
							      >	// local functions
							      >	static void eth_send_raw_packet(uint8_t *pkt, uint16_t pkt_le
							      >	static bool eth_dispatch_eth(const uint8_t *data, const uint1
							      >	static bool eth_dispatch_ip(const uint8_t *data, const uint16
							      >	static bool eth_dispatch_udp(const uint8_t *data, const uint1
							      >
							      >	/////////////////////////////////////////////////////////////
							      >
uint16_t enet_read_phy_reg(const uint8_t reg_idx)		uint16_t enet_read_phy_reg(const uint8_t reg_idx)
{								{
  while (ETH->MACMIIAR & ETH_MACMIIAR_MB) { } // ensure MII i	  while (ETH->MACMIIAR & ETH_MACMIIAR_MB) { } // ensure MII i
  ETH->MACMIIAR = (ENET_PHY_ADDR << 11) |			  ETH->MACMIIAR = (ENET_PHY_ADDR << 11) |
                  ((reg_idx & 0x1f) << 6) |			                  ((reg_idx & 0x1f) << 6) |
                  ETH_MACMIIAR_CR_Div102  | // clock divider	                  ETH_MACMIIAR_CR_Div102  | // clock divider
                  ETH_MACMIIAR_MB;				                  ETH_MACMIIAR_MB;
  while (ETH->MACMIIAR & ETH_MACMIIAR_MB) { } // spin waiting	  while (ETH->MACMIIAR & ETH_MACMIIAR_MB) { } // spin waiting
  return ETH->MACMIIDR & 0xffff;				  return ETH->MACMIIDR & 0xffff;
}								}

void enet_write_phy_reg(const uint8_t reg_idx, const uint16_t	void enet_write_phy_reg(const uint8_t reg_idx, const uint16_t
{								{
  while (ETH->MACMIIAR & ETH_MACMIIAR_MB) { } // ensure MII i	  while (ETH->MACMIIAR & ETH_MACMIIAR_MB) { } // ensure MII i
  ETH->MACMIIDR = reg_val; // set the outgoing data word	  ETH->MACMIIDR = reg_val; // set the outgoing data word
  ETH->MACMIIAR = (ENET_PHY_ADDR << 11)   |			  ETH->MACMIIAR = (ENET_PHY_ADDR << 11)   |
                  ((reg_idx & 0x1f) << 6) |			                  ((reg_idx & 0x1f) << 6) |
                  ETH_MACMIIAR_CR_Div102  | // MDC clock divi	                  ETH_MACMIIAR_CR_Div102  | // MDC clock divi
                  ETH_MACMIIAR_MW         | // set the write 	                  ETH_MACMIIAR_MW         | // set the write 
                  ETH_MACMIIAR_MB; // start it up		                  ETH_MACMIIAR_MB; // start it up
  while (ETH->MACMIIAR & ETH_MACMIIAR_MB) { } // spin waiting	  while (ETH->MACMIIAR & ETH_MACMIIAR_MB) { } // spin waiting
  uint16_t readback_val = enet_read_phy_reg(reg_idx);		  uint16_t readback_val = enet_read_phy_reg(reg_idx);
  if (readback_val != reg_val)					  if (readback_val != reg_val)
  {								  {
    printf("woah there. tried to write 0x%04x to reg %02d but	    printf("woah there. tried to write 0x%04x to reg %02d but
           reg_val, reg_idx, readback_val);			           reg_val, reg_idx, readback_val);
  }								  }
}								}

void enet_init()						void enet_init()
{								{
  printf("enet_init()\r\n");					  printf("enet_init()\r\n");
  // set up the pins on port a					  // set up the pins on port a
  RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN     |  // and all the i	  RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN     |  // and all the i
                  RCC_AHB1ENR_GPIOBEN     |  // will be using	                  RCC_AHB1ENR_GPIOBEN     |  // will be using
                  RCC_AHB1ENR_GPIOCEN;       // the ethernet 	                  RCC_AHB1ENR_GPIOCEN;       // the ethernet 

  GPIOA->MODER |= (2 << (PORTA_ETH_REFCLK * 2)) |		  GPIOA->MODER |= (2 << (PORTA_ETH_REFCLK * 2)) |
                  (2 << (PORTA_ETH_MDIO   * 2)) |		                  (2 << (PORTA_ETH_MDIO   * 2)) |
                  (2 << (PORTA_ETH_CRSDV  * 2)); // set these	                  (2 << (PORTA_ETH_CRSDV  * 2)); // set these
  GPIOA->AFR[0] |= (11 << (PORTA_ETH_REFCLK * 4)) |		  GPIOA->AFR[0] |= (11 << (PORTA_ETH_REFCLK * 4)) |
                   (11 << (PORTA_ETH_MDIO   * 4)) |		                   (11 << (PORTA_ETH_MDIO   * 4)) |
                   (11 << (PORTA_ETH_CRSDV  * 4));		                   (11 << (PORTA_ETH_CRSDV  * 4));

  // set up the ethernet pins on port b				  // set up the ethernet pins on port b
  GPIOB->MODER |= (2 << (PORTB_ETH_TXEN * 2)) |			  GPIOB->MODER |= (2 << (PORTB_ETH_TXEN * 2)) |
                  (2 << (PORTB_ETH_TXD0 * 2)) |			                  (2 << (PORTB_ETH_TXD0 * 2)) |
                  (2 << (PORTB_ETH_TXD1 * 2));			                  (2 << (PORTB_ETH_TXD1 * 2));
  GPIOB->AFR[1] |= (11 << ((PORTB_ETH_TXEN - 8) * 4)) |		  GPIOB->AFR[1] |= (11 << ((PORTB_ETH_TXEN - 8) * 4)) |
                   (11 << ((PORTB_ETH_TXD0 - 8) * 4)) |		                   (11 << ((PORTB_ETH_TXD0 - 8) * 4)) |
                   (11 << ((PORTB_ETH_TXD1 - 8) * 4));		                   (11 << ((PORTB_ETH_TXD1 - 8) * 4));
  GPIOB->OSPEEDR |= (3 << (PORTB_ETH_TXEN * 2)) |		  GPIOB->OSPEEDR |= (3 << (PORTB_ETH_TXEN * 2)) |
                    (3 << (PORTB_ETH_TXD0 * 2)) |		                    (3 << (PORTB_ETH_TXD0 * 2)) |
                    (3 << (PORTB_ETH_TXD1 * 2)); // make the 	                    (3 << (PORTB_ETH_TXD1 * 2)); // make the 
  GPIOB->MODER |= (1 << (PORTB_PHY_RESET * 2)); // reset = gp	  GPIOB->MODER |= (1 << (PORTB_PHY_RESET * 2)); // reset = gp

  // set up the ethernet pins on port c				  // set up the ethernet pins on port c
  GPIOC->MODER  |= ( 2 << (PORTC_ETH_MDC  * 2)) |		  GPIOC->MODER  |= ( 2 << (PORTC_ETH_MDC  * 2)) |
                   ( 2 << (PORTC_ETH_RXD0 * 2)) |		                   ( 2 << (PORTC_ETH_RXD0 * 2)) |
                   ( 2 << (PORTC_ETH_RXD1 * 2));		                   ( 2 << (PORTC_ETH_RXD1 * 2));
  GPIOC->AFR[0] |= (11 << (PORTC_ETH_MDC  * 4)) |		  GPIOC->AFR[0] |= (11 << (PORTC_ETH_MDC  * 4)) |
                   (11 << (PORTC_ETH_RXD0 * 4)) |		                   (11 << (PORTC_ETH_RXD0 * 4)) |
                   (11 << (PORTC_ETH_RXD1 * 4));		                   (11 << (PORTC_ETH_RXD1 * 4));

  RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN; // enable the sysconf	  RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN; // enable the sysconf
  RCC->AHB1RSTR |= RCC_AHB1RSTR_ETHMACRST;			  RCC->AHB1RSTR |= RCC_AHB1RSTR_ETHMACRST;
  for (volatile int i = 0; i < 1000; i++) { } // wait for sys	  for (volatile int i = 0; i < 1000; i++) { } // wait for sys
  // hold the MAC in reset while we set it to RMII mode		  // hold the MAC in reset while we set it to RMII mode
  for (volatile int i = 0; i < 1000; i++) { } // wait for sys	  for (volatile int i = 0; i < 1000; i++) { } // wait for sys
  SYSCFG->PMC |= SYSCFG_PMC_MII_RMII_SEL; // set the MAC in R	  SYSCFG->PMC |= SYSCFG_PMC_MII_RMII_SEL; // set the MAC in R
  for (volatile int i = 0; i < 100000; i++) { } // wait for s	  for (volatile int i = 0; i < 100000; i++) { } // wait for s
  RCC->AHB1ENR |= RCC_AHB1ENR_ETHMACRXEN  |			  RCC->AHB1ENR |= RCC_AHB1ENR_ETHMACRXEN  |
                  RCC_AHB1ENR_ETHMACTXEN  |			                  RCC_AHB1ENR_ETHMACTXEN  |
                  RCC_AHB1ENR_ETHMACEN    ;  // turn on ur et	                  RCC_AHB1ENR_ETHMACEN    ;  // turn on ur et
  for (volatile int i = 0; i < 100000; i++) { } // wait		  for (volatile int i = 0; i < 100000; i++) { } // wait
  RCC->AHB1RSTR &= ~RCC_AHB1RSTR_ETHMACRST; // release MAC re	  RCC->AHB1RSTR &= ~RCC_AHB1RSTR_ETHMACRST; // release MAC re
  for (volatile int i = 0; i < 100000; i++) { } // wait		  for (volatile int i = 0; i < 100000; i++) { } // wait
  RCC->AHB1RSTR |= RCC_AHB1RSTR_ETHMACRST;			  RCC->AHB1RSTR |= RCC_AHB1RSTR_ETHMACRST;
  for (volatile int i = 0; i < 100000; i++) { } // wait		  for (volatile int i = 0; i < 100000; i++) { } // wait
  RCC->AHB1RSTR &= ~RCC_AHB1RSTR_ETHMACRST; // release MAC re	  RCC->AHB1RSTR &= ~RCC_AHB1RSTR_ETHMACRST; // release MAC re
  for (volatile int i = 0; i < 100000; i++) { } // wait for s	  for (volatile int i = 0; i < 100000; i++) { } // wait for s

  ETH->DMABMR |= ETH_DMABMR_SR;					  ETH->DMABMR |= ETH_DMABMR_SR;
  for (volatile uint32_t i = 0; i < 100000; i++) { }		  for (volatile uint32_t i = 0; i < 100000; i++) { }
  while (ETH->DMABMR & ETH_DMABMR_SR) { } // wait for it to r	  while (ETH->DMABMR & ETH_DMABMR_SR) { } // wait for it to r
  for (volatile uint32_t i = 0; i < 100000; i++) { }		  for (volatile uint32_t i = 0; i < 100000; i++) { }
  ETH->DMAOMR |= ETH_DMAOMR_FTF; // flush DMA			  ETH->DMAOMR |= ETH_DMAOMR_FTF; // flush DMA
  while (ETH->DMAOMR & ETH_DMAOMR_FTF) { } // wait for it to 	  while (ETH->DMAOMR & ETH_DMAOMR_FTF) { } // wait for it to 

  // now, configure the ethernet peripheral			  // now, configure the ethernet peripheral
  ETH->MACCR |= 0x02000000 | // CSTF = strip FCS. why isn't t	  ETH->MACCR |= 0x02000000 | // CSTF = strip FCS. why isn't t
                ETH_MACCR_FES  | // enable 100 mbit mode	                ETH_MACCR_FES  | // enable 100 mbit mode
                ETH_MACCR_DM   | // full duplex			                ETH_MACCR_DM   | // full duplex
                ETH_MACCR_IPCO | // ipv4 checksum auto-genera	                ETH_MACCR_IPCO | // ipv4 checksum auto-genera
                ETH_MACCR_APCS;  // automatically remove pad+	                ETH_MACCR_APCS;  // automatically remove pad+
  ETH->MACFFR |= ETH_MACFFR_RA; // for now, don't try to filt	  ETH->MACFFR |= ETH_MACFFR_RA; // for now, don't try to filt
  // generate a decent reset pulse now				  // generate a decent reset pulse now
  GPIOB->BSRRL = 1 << PORTB_PHY_RESET;				  GPIOB->BSRRL = 1 << PORTB_PHY_RESET;
  for (volatile uint32_t i = 0; i < 100000; i++) { }		  for (volatile uint32_t i = 0; i < 100000; i++) { }
  GPIOB->BSRRH = 1 << PORTB_PHY_RESET; // assert reset (pull 	  GPIOB->BSRRH = 1 << PORTB_PHY_RESET; // assert reset (pull 
  for (volatile uint32_t i = 0; i < 100000; i++) { } // let s	  for (volatile uint32_t i = 0; i < 100000; i++) { } // let s
  GPIOB->BSRRL = 1 << PORTB_PHY_RESET; // de-assert reset (pu	  GPIOB->BSRRL = 1 << PORTB_PHY_RESET; // de-assert reset (pu
  // todo: only need to wait until registers read back someth	  // todo: only need to wait until registers read back someth
  // than 0xffff . then we don't have to wait as long.		  // than 0xffff . then we don't have to wait as long.
  for (volatile uint32_t i = 0; i < 1000000; i++) { } // let 	  for (volatile uint32_t i = 0; i < 1000000; i++) { } // let 
  printf("waiting for PHY to wake up...\r\n");			  printf("waiting for PHY to wake up...\r\n");
  while (enet_read_phy_reg(0) == 0xffff) { }			  while (enet_read_phy_reg(0) == 0xffff) { }
  for (volatile uint32_t i = 0; i < 1000000; i++) { } // let 	  for (volatile uint32_t i = 0; i < 1000000; i++) { } // let 
  printf("done with PHY reset.\r\n");				  printf("done with PHY reset.\r\n");
  printf("setting software strap registers...\r\n");		  printf("setting software strap registers...\r\n");
  enet_write_phy_reg(0x09, 0x7821); // enable auto MDIX,	  enet_write_phy_reg(0x09, 0x7821); // enable auto MDIX,
                                    // set INT/PWDN to be int	                                    // set INT/PWDN to be int
                                    // enable auto-negotiatio	                                    // enable auto-negotiatio
  enet_write_phy_reg(0x09, 0xf821); // exit software-strap mo	  enet_write_phy_reg(0x09, 0xf821); // exit software-strap mo
  enet_write_phy_reg(0x04, 0x0101); // only advertise 100-FD 	  enet_write_phy_reg(0x04, 0x0101); // only advertise 100-FD 

  // cycle through and read a bunch of PHY registers to make 	  // cycle through and read a bunch of PHY registers to make 
  for (int i = 0; i < 32; i++)					  for (int i = 0; i < 32; i++)
    printf("PHY reg %02d = 0x%04x\r\n", i, enet_read_phy_reg(	    printf("PHY reg %02d = 0x%04x\r\n", i, enet_read_phy_reg(

  ///////////////////////////////////////////////////////////	  ///////////////////////////////////////////////////////////
  // set up ethernet TX descriptors				  // set up ethernet TX descriptors
  for (int i = 0; i < ETH_DMA_NTXD; i++)			  for (int i = 0; i < ETH_DMA_NTXD; i++)
  {								  {
    g_eth_dma_tx_desc[i].des0 = 0x00100000 | // set address-c	    g_eth_dma_tx_desc[i].des0 = 0x00100000 | // set address-c
                                0x00c00000 ; // set insert-ch	                                0x00c00000 ; // set insert-ch
    g_eth_dma_tx_desc[i].des1 = 0;				    g_eth_dma_tx_desc[i].des1 = 0;
    g_eth_dma_tx_desc[i].des2 = (uint32_t)&g_eth_dma_tx_buf[i	    g_eth_dma_tx_desc[i].des2 = (uint32_t)&g_eth_dma_tx_buf[i
    if (i < ETH_DMA_NTXD-1)					    if (i < ETH_DMA_NTXD-1)
      g_eth_dma_tx_desc[i].des3 = (uint32_t)&g_eth_dma_tx_des	      g_eth_dma_tx_desc[i].des3 = (uint32_t)&g_eth_dma_tx_des
    else							    else
      g_eth_dma_tx_desc[i].des3 = (uint32_t)&g_eth_dma_tx_des	      g_eth_dma_tx_desc[i].des3 = (uint32_t)&g_eth_dma_tx_des
  }								  }
  ///////////////////////////////////////////////////////////	  ///////////////////////////////////////////////////////////
  // set up ethernet RX descriptors				  // set up ethernet RX descriptors
  for (int i = 0; i < ETH_DMA_NRXD; i++)			  for (int i = 0; i < ETH_DMA_NRXD; i++)
  {								  {
    g_eth_dma_rx_desc[i].des0 = 0x80000000; // set "own" bit 	    g_eth_dma_rx_desc[i].des0 = 0x80000000; // set "own" bit 
    g_eth_dma_rx_desc[i].des1 = 0x00004000 | // set the RCH b	    g_eth_dma_rx_desc[i].des1 = 0x00004000 | // set the RCH b
                            ETH_NBUF; // buffer size in addr1	                            ETH_NBUF; // buffer size in addr1
    g_eth_dma_rx_desc[i].des2 = (uint32_t)&g_eth_dma_rx_buf[i	    g_eth_dma_rx_desc[i].des2 = (uint32_t)&g_eth_dma_rx_buf[i
    if (i < ETH_DMA_NRXD-1)					    if (i < ETH_DMA_NRXD-1)
      g_eth_dma_rx_desc[i].des3 = (uint32_t)&g_eth_dma_rx_des	      g_eth_dma_rx_desc[i].des3 = (uint32_t)&g_eth_dma_rx_des
    else							    else
      g_eth_dma_rx_desc[i].des3 = (uint32_t)&g_eth_dma_rx_des	      g_eth_dma_rx_desc[i].des3 = (uint32_t)&g_eth_dma_rx_des
  }								  }

  ///////////////////////////////////////////////////////////	  ///////////////////////////////////////////////////////////
  // set up the RAM pool for reception				  // set up the RAM pool for reception
  for (int i = 0; i < ETH_RAM_RXPOOL_NPTR; i++)			  for (int i = 0; i < ETH_RAM_RXPOOL_NPTR; i++)
  {								  {
    g_eth_rxpool_start[i] = &g_eth_rxpool[0];			    g_eth_rxpool_start[i] = &g_eth_rxpool[0];
    g_eth_rxpool_len[i] = 0;					    g_eth_rxpool_len[i] = 0;
    g_eth_rxpool_ptrs_wpos = 0;					    g_eth_rxpool_ptrs_wpos = 0;
    g_eth_rxpool_ptrs_rpos = 0;					    g_eth_rxpool_ptrs_rpos = 0;
  }								  }

  ///////////////////////////////////////////////////////////	  ///////////////////////////////////////////////////////////
  // finally, turn on the DMA machinery				  // finally, turn on the DMA machinery
  ETH->DMATDLAR = (uint32_t)&g_eth_dma_tx_desc[0]; // point T	  ETH->DMATDLAR = (uint32_t)&g_eth_dma_tx_desc[0]; // point T
  ETH->DMARDLAR = (uint32_t)&g_eth_dma_rx_desc[0]; // point R	  ETH->DMARDLAR = (uint32_t)&g_eth_dma_rx_desc[0]; // point R
  ETH->DMAOMR = ETH_DMAOMR_TSF; // enable store-and-forward m	  ETH->DMAOMR = ETH_DMAOMR_TSF; // enable store-and-forward m
  /*								  /*
  ETH->DMABMR = ETH_DMABMR_AAB | ETH_DMABMR_USP |		  ETH->DMABMR = ETH_DMABMR_AAB | ETH_DMABMR_USP |
                ETH_DMABMR_RDP_1Beat | ETH_DMABMR_RTPR_1_1 |	                ETH_DMABMR_RDP_1Beat | ETH_DMABMR_RTPR_1_1 |
                ETH_DMABMR_PBL_1Beat | ETH_DMABMR_EDE;		                ETH_DMABMR_PBL_1Beat | ETH_DMABMR_EDE;
  */								  */
  ETH->DMAIER = ETH_DMAIER_NISE | ETH_DMAIER_RIE;		  ETH->DMAIER = ETH_DMAIER_NISE | ETH_DMAIER_RIE;
  ETH->MACCR |= ETH_MACCR_TE | // enable transmitter		  ETH->MACCR |= ETH_MACCR_TE | // enable transmitter
                ETH_MACCR_RE;  // enable receiver		                ETH_MACCR_RE;  // enable receiver
  NVIC_SetPriority(ETH_IRQn, 3);				  NVIC_SetPriority(ETH_IRQn, 3);
  NVIC_EnableIRQ(ETH_IRQn);					  NVIC_EnableIRQ(ETH_IRQn);
  ETH->DMAOMR |= ETH_DMAOMR_ST | ETH_DMAOMR_SR; // enable eth	  ETH->DMAOMR |= ETH_DMAOMR_ST | ETH_DMAOMR_SR; // enable eth
}								}

void eth_vector()						void eth_vector()
{								{
  volatile uint32_t dmasr = ETH->DMASR;				  volatile uint32_t dmasr = ETH->DMASR;
  ETH->DMASR = dmasr; // clear pending bits in the status reg	  ETH->DMASR = dmasr; // clear pending bits in the status reg
  //printf("eth_vector()\r\n");					  //printf("eth_vector()\r\n");
  if (dmasr & ETH_DMASR_RS)					  if (dmasr & ETH_DMASR_RS)
  {								  {
    // we received one or more frames. spin through and find 	    // we received one or more frames. spin through and find 
    while (!(g_eth_dma_rx_next_desc->des0 & 0x80000000))	    while (!(g_eth_dma_rx_next_desc->des0 & 0x80000000))
    {								    {
      // todo: check all of the error status bits in des0...	      // todo: check all of the error status bits in des0...
      const uint16_t rxn = (g_eth_dma_rx_next_desc->des0 & 0x	      const uint16_t rxn = (g_eth_dma_rx_next_desc->des0 & 0x
      // see if this packet will run off the end of the buffe	      // see if this packet will run off the end of the buffe
      if (g_eth_rxpool_wpos + rxn >= ETH_RAM_RXPOOL_LEN)	      if (g_eth_rxpool_wpos + rxn >= ETH_RAM_RXPOOL_LEN)
        g_eth_rxpool_wpos = 0;					        g_eth_rxpool_wpos = 0;
      const uint16_t wp = g_eth_rxpool_ptrs_wpos;		      const uint16_t wp = g_eth_rxpool_ptrs_wpos;
      g_eth_rxpool_start[wp] = &g_eth_rxpool[g_eth_rxpool_wpo	      g_eth_rxpool_start[wp] = &g_eth_rxpool[g_eth_rxpool_wpo
      g_eth_rxpool_len[wp] = rxn;				      g_eth_rxpool_len[wp] = rxn;
      memcpy((uint8_t *)&g_eth_rxpool[g_eth_rxpool_wpos],	      memcpy((uint8_t *)&g_eth_rxpool[g_eth_rxpool_wpos],
             (const uint8_t *)g_eth_dma_rx_next_desc->des2,	             (const uint8_t *)g_eth_dma_rx_next_desc->des2,
             rxn);						             rxn);
      //printf("ethernet rx %d into rxpool ptr %d\r\n", rxn, 	      //printf("ethernet rx %d into rxpool ptr %d\r\n", rxn, 
      g_eth_rxpool_ptrs_wpos++;					      g_eth_rxpool_ptrs_wpos++;
      if (g_eth_rxpool_ptrs_wpos >= ETH_RAM_RXPOOL_NPTR)	      if (g_eth_rxpool_ptrs_wpos >= ETH_RAM_RXPOOL_NPTR)
        g_eth_rxpool_ptrs_wpos = 0;				        g_eth_rxpool_ptrs_wpos = 0;
      g_eth_rxpool_wpos += rxn;					      g_eth_rxpool_wpos += rxn;

/*								/*
      uint8_t *p = (uint8_t *)g_eth_rx_next_desc->des2;		      uint8_t *p = (uint8_t *)g_eth_rx_next_desc->des2;
      for (int i = 0; i < rxn; i++)				      for (int i = 0; i < rxn; i++)
        printf("%02d: 0x%02x\r\n", i, p[i]);			        printf("%02d: 0x%02x\r\n", i, p[i]);
*/								*/

      g_eth_dma_rx_next_desc->des0 |= 0x80000000; // give it 	      g_eth_dma_rx_next_desc->des0 |= 0x80000000; // give it 
      // advance the rx pointer for next time			      // advance the rx pointer for next time
      g_eth_dma_rx_next_desc = (eth_dma_desc_t *)g_eth_dma_rx	      g_eth_dma_rx_next_desc = (eth_dma_desc_t *)g_eth_dma_rx
    }								    }
  }								  }
  dmasr = ETH->DMASR;						  dmasr = ETH->DMASR;
  //printf("dmasr = 0x%08x\r\n", (int)dmasr);			  //printf("dmasr = 0x%08x\r\n", (int)dmasr);
}								}

enet_link_status_t enet_get_link_status()			enet_link_status_t enet_get_link_status()
{								{
  uint16_t status = enet_read_phy_reg(0x01);			  uint16_t status = enet_read_phy_reg(0x01);
  //printf("PHY status = 0x%02x\r\n", status);			  //printf("PHY status = 0x%02x\r\n", status);
  if (status & (1 << 4)) {					  if (status & (1 << 4)) {
    err_set(ERR_ETH_REMOTE_FAULT);				    err_set(ERR_ETH_REMOTE_FAULT);
  } else {							  } else {
    err_unset(ERR_ETH_REMOTE_FAULT);				    err_unset(ERR_ETH_REMOTE_FAULT);
  }								  }
  if (status & (1 << 5)) {					  if (status & (1 << 5)) {
    err_unset(ERR_ETH_NEGOTIATING);				    err_unset(ERR_ETH_NEGOTIATING);
  } else {							  } else {
    err_set(ERR_ETH_NEGOTIATING);				    err_set(ERR_ETH_NEGOTIATING);
  }								  }
  if (status & (1 << 2))					  if (status & (1 << 2))
    return ENET_LINK_UP;					    return ENET_LINK_UP;
  return ENET_LINK_DOWN;					  return ENET_LINK_DOWN;
}								}

void eth_send_raw_packet(uint8_t *pkt, uint16_t pkt_len)	void eth_send_raw_packet(uint8_t *pkt, uint16_t pkt_len)
{								{
  //printf("eth tx %d\r\n", pkt_len);				  //printf("eth tx %d\r\n", pkt_len);
  if (g_eth_dma_tx_next_desc->des0 & 0x80000000) // check the	  if (g_eth_dma_tx_next_desc->des0 & 0x80000000) // check the
  {								  {
    err_set(ERR_ETH_BUFFER_FULL);				    err_set(ERR_ETH_BUFFER_FULL);
    return; // if it's set, then we have run out of ringbuffe	    return; // if it's set, then we have run out of ringbuffe
  }								  }
  err_unset(ERR_ETH_BUFFER_FULL);				  err_unset(ERR_ETH_BUFFER_FULL);
  /*								  /*
  printf("sending using TX descriptor %08x status 0x%08x\r\n"	  printf("sending using TX descriptor %08x status 0x%08x\r\n"
         (unsigned)g_eth_tx_next_desc,				         (unsigned)g_eth_tx_next_desc,
         (unsigned)g_eth_tx_next_desc->control);		         (unsigned)g_eth_tx_next_desc->control);
 */								 */
  uint8_t *buf = (uint8_t *)g_eth_dma_tx_next_desc->des2;	  uint8_t *buf = (uint8_t *)g_eth_dma_tx_next_desc->des2;
  if (pkt_len > ETH_NBUF)					  if (pkt_len > ETH_NBUF)
    pkt_len = ETH_NBUF; // let's not blow through our packet 	    pkt_len = ETH_NBUF; // let's not blow through our packet 
  memcpy(buf, pkt, pkt_len);					  memcpy(buf, pkt, pkt_len);
  g_eth_dma_tx_next_desc->des1 = pkt_len;			  g_eth_dma_tx_next_desc->des1 = pkt_len;
  g_eth_dma_tx_next_desc->des0 |= 0x30000000; // LS+FS = sing	  g_eth_dma_tx_next_desc->des0 |= 0x30000000; // LS+FS = sing
  g_eth_dma_tx_next_desc->des0 |= 0x80000000; // give ownersh	  g_eth_dma_tx_next_desc->des0 |= 0x80000000; // give ownersh
  // see if DMA is stuck because it wasn't transmitting (whic	  // see if DMA is stuck because it wasn't transmitting (whic
  // always be the case). if it's stuck, kick it into motion 	  // always be the case). if it's stuck, kick it into motion 
  if ((ETH->DMASR & ETH_DMASR_TPS) == ETH_DMASR_TPS_Suspended	  if ((ETH->DMASR & ETH_DMASR_TPS) == ETH_DMASR_TPS_Suspended
  {								  {
    ETH->DMASR = ETH_DMASR_TBUS; // clear the buffer-unavaila	    ETH->DMASR = ETH_DMASR_TBUS; // clear the buffer-unavaila
    ETH->DMATPDR = 0; // transmit poll demand = kick it movin	    ETH->DMATPDR = 0; // transmit poll demand = kick it movin
  }								  }
  g_eth_dma_tx_next_desc = (eth_dma_desc_t *)g_eth_dma_tx_nex	  g_eth_dma_tx_next_desc = (eth_dma_desc_t *)g_eth_dma_tx_nex
  //uint16_t r = enet_read_phy_reg(0x17);			  //uint16_t r = enet_read_phy_reg(0x17);
  //printf(" rmii status = 0x%04x\r\n", (unsigned)r);		  //printf(" rmii status = 0x%04x\r\n", (unsigned)r);
}								}

// todo: find ways for this to be overridden on CPU's with bu	// todo: find ways for this to be overridden on CPU's with bu
uint16_t eth_htons(const uint16_t x)				uint16_t eth_htons(const uint16_t x)
{								{
  return ((x & 0xff) << 8) | ((x >> 8) & 0xff);			  return ((x & 0xff) << 8) | ((x >> 8) & 0xff);
}								}

uint32_t eth_htonl(const uint32_t x)				uint32_t eth_htonl(const uint32_t x)
{								{
  return ((x & 0x000000ff) << 24)  |				  return ((x & 0x000000ff) << 24)  |
         ((x & 0x0000ff00) << 8)   |				         ((x & 0x0000ff00) << 8)   |
         ((x & 0x00ff0000) >> 8)   |				         ((x & 0x00ff0000) >> 8)   |
         ((x & 0xff000000) >> 24);				         ((x & 0xff000000) >> 24);
}								}

#define ETH_MAC_LEN 6						#define ETH_MAC_LEN 6
typedef struct							typedef struct
{								{
  uint8_t  dest_addr[ETH_MAC_LEN];				  uint8_t  dest_addr[ETH_MAC_LEN];
  uint8_t  source_addr[ETH_MAC_LEN];				  uint8_t  source_addr[ETH_MAC_LEN];
  uint16_t ethertype : 16;					  uint16_t ethertype : 16;
} __attribute__((packed)) eth_eth_header_t;			} __attribute__((packed)) eth_eth_header_t;

#define ETH_ETHERTYPE_IP    0x0800				#define ETH_ETHERTYPE_IP    0x0800
#define ETH_ETHERTYPE_ARP   0x0806				#define ETH_ETHERTYPE_ARP   0x0806

typedef struct							typedef struct
{								{
  eth_eth_header_t eth;						  eth_eth_header_t eth;
  uint8_t  header_len   :  4;					  uint8_t  header_len   :  4;
  uint8_t  version      :  4;					  uint8_t  version      :  4;
  uint8_t  ecn          :  2;					  uint8_t  ecn          :  2;
  uint8_t  diff_serv    :  6;					  uint8_t  diff_serv    :  6;
  uint16_t len          : 16;					  uint16_t len          : 16;
  uint16_t id           : 16;					  uint16_t id           : 16;
  uint16_t flag_frag    : 16;					  uint16_t flag_frag    : 16;
  uint8_t  ttl          :  8;					  uint8_t  ttl          :  8;
  uint8_t  proto        :  8;					  uint8_t  proto        :  8;
  uint16_t checksum     : 16;					  uint16_t checksum     : 16;
  uint32_t source_addr  : 32;					  uint32_t source_addr  : 32;
  uint32_t dest_addr    : 32;					  uint32_t dest_addr    : 32;
} __attribute__((packed)) eth_ip_header_t;			} __attribute__((packed)) eth_ip_header_t;

#define ETH_IP_HEADER_LEN     5					#define ETH_IP_HEADER_LEN     5
#define ETH_IP_VERSION        4					#define ETH_IP_VERSION        4
#define ETH_IP_DONT_FRAGMENT  0x4000				#define ETH_IP_DONT_FRAGMENT  0x4000

#define ETH_IP_PROTO_ICMP  0x01					#define ETH_IP_PROTO_ICMP  0x01
#define ETH_IP_PROTO_UDP   0x11					#define ETH_IP_PROTO_UDP   0x11

typedef struct							typedef struct
{								{
  eth_ip_header_t ip;						  eth_ip_header_t ip;
  uint16_t source_port;						  uint16_t source_port;
  uint16_t dest_port;						  uint16_t dest_port;
  uint16_t len;							  uint16_t len;
  uint16_t checksum;						  uint16_t checksum;
} __attribute__((packed)) eth_udp_header_t;			} __attribute__((packed)) eth_udp_header_t;

static uint8_t  g_eth_udpbuf[1500] __attribute__((aligned(8))	static uint8_t  g_eth_udpbuf[1500] __attribute__((aligned(8))
static uint8_t  g_eth_src_mac[6] = { 0xa4, 0xf3, 0xc1, 0x00, 	static uint8_t  g_eth_src_mac[6] = { 0xa4, 0xf3, 0xc1, 0x00, 
static uint32_t g_eth_src_ip = 0x0a636363; // todo... not thi	static uint32_t g_eth_src_ip = 0x0a636363; // todo... not thi

void enet_send_udp_mcast(const uint32_t mcast_ip, const uint1	void enet_send_udp_mcast(const uint32_t mcast_ip, const uint1
                         const uint8_t *payload, const uint16	                         const uint8_t *payload, const uint16
{								{
  uint8_t dest_mac[6] = { 0x01, 0x00, 0x5e,			  uint8_t dest_mac[6] = { 0x01, 0x00, 0x5e,
                          (uint8_t)((mcast_ip & 0xff0000) >> 	                          (uint8_t)((mcast_ip & 0xff0000) >> 
                          (uint8_t)((mcast_ip & 0x00ff00) >> 	                          (uint8_t)((mcast_ip & 0x00ff00) >> 
                          (uint8_t) (mcast_ip & 0x0000ff) };	                          (uint8_t) (mcast_ip & 0x0000ff) };
  enet_send_udp_ucast(dest_mac, mcast_ip, mcast_port,		  enet_send_udp_ucast(dest_mac, mcast_ip, mcast_port,
                      g_eth_src_ip, mcast_port,			                      g_eth_src_ip, mcast_port,
                      payload, payload_len);			                      payload, payload_len);
}								}

void enet_send_udp_ucast(const uint8_t *dest_mac,		void enet_send_udp_ucast(const uint8_t *dest_mac,
                         const uint32_t dest_ip, const uint16	                         const uint32_t dest_ip, const uint16
                         const uint32_t source_ip, const uint	                         const uint32_t source_ip, const uint
                         const uint8_t *payload, const uint16	                         const uint8_t *payload, const uint16
{								{
  eth_udp_header_t *h = (eth_udp_header_t *)&g_eth_udpbuf[0];	  eth_udp_header_t *h = (eth_udp_header_t *)&g_eth_udpbuf[0];
  for (int i = 0; i < 6; i++)					  for (int i = 0; i < 6; i++)
  {								  {
    h->ip.eth.dest_addr[i] = dest_mac[i];			    h->ip.eth.dest_addr[i] = dest_mac[i];
    h->ip.eth.source_addr[i] = g_eth_src_mac[i];		    h->ip.eth.source_addr[i] = g_eth_src_mac[i];
  }								  }
  h->ip.eth.ethertype = eth_htons(ETH_ETHERTYPE_IP);		  h->ip.eth.ethertype = eth_htons(ETH_ETHERTYPE_IP);
  h->ip.header_len = ETH_IP_HEADER_LEN;				  h->ip.header_len = ETH_IP_HEADER_LEN;
  h->ip.version = ETH_IP_VERSION; // ipv4			  h->ip.version = ETH_IP_VERSION; // ipv4
  h->ip.ecn = 0;						  h->ip.ecn = 0;
  h->ip.diff_serv = 0;						  h->ip.diff_serv = 0;
  h->ip.len = eth_htons(20 + 8 + payload_len);			  h->ip.len = eth_htons(20 + 8 + payload_len);
  h->ip.id = 0;							  h->ip.id = 0;
  h->ip.flag_frag = eth_htons(ETH_IP_DONT_FRAGMENT);		  h->ip.flag_frag = eth_htons(ETH_IP_DONT_FRAGMENT);
  h->ip.ttl = 1; // not sure here...				  h->ip.ttl = 1; // not sure here...
  h->ip.proto = ETH_IP_PROTO_UDP;				  h->ip.proto = ETH_IP_PROTO_UDP;
  h->ip.checksum = 0; // will be filled by the ethernet TX ma	  h->ip.checksum = 0; // will be filled by the ethernet TX ma
  h->ip.dest_addr = eth_htonl(dest_ip);				  h->ip.dest_addr = eth_htonl(dest_ip);
  h->ip.source_addr = eth_htonl(source_ip); //); // todo: som	  h->ip.source_addr = eth_htonl(source_ip); //); // todo: som
  h->dest_port = eth_htons(dest_port);				  h->dest_port = eth_htons(dest_port);
  h->source_port = eth_htons(source_port); //1234;		  h->source_port = eth_htons(source_port); //1234;
  h->len = eth_htons(8 + payload_len);				  h->len = eth_htons(8 + payload_len);
  h->checksum = 0; // will be filled by the ethernet TX machi	  h->checksum = 0; // will be filled by the ethernet TX machi
  memcpy(g_eth_udpbuf + sizeof(eth_udp_header_t), payload, pa	  memcpy(g_eth_udpbuf + sizeof(eth_udp_header_t), payload, pa
  eth_send_raw_packet(g_eth_udpbuf, sizeof(eth_udp_header_t) 	  eth_send_raw_packet(g_eth_udpbuf, sizeof(eth_udp_header_t) 
  /*								  /*
  uint8_t raw_test_pkt[128] =					  uint8_t raw_test_pkt[128] =
  { 0x01, 0x00, 0x5e, 0x00, 0x00, 0x7b, 0x90, 0x2b,		  { 0x01, 0x00, 0x5e, 0x00, 0x00, 0x7b, 0x90, 0x2b,
    0x34, 0x39, 0xb3, 0x2e, 0x08, 0x00, 0x45, 0x00,		    0x34, 0x39, 0xb3, 0x2e, 0x08, 0x00, 0x45, 0x00,
    0x00, 0x2b, 0x00, 0x00, 0x40, 0x00, 0x01, 0x11,		    0x00, 0x2b, 0x00, 0x00, 0x40, 0x00, 0x01, 0x11,
    0xd7, 0x1e, 0xc0, 0xa8, 0x01, 0x80, 0xe0, 0x00,		    0xd7, 0x1e, 0xc0, 0xa8, 0x01, 0x80, 0xe0, 0x00,
    0x00, 0x7b, 0xcc, 0xad, 0x04, 0xd4, 0x00, 0x17,		    0x00, 0x7b, 0xcc, 0xad, 0x04, 0xd4, 0x00, 0x17,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x0b, 0x00, 0x00,		    0x00, 0x00, 0x01, 0x01, 0x00, 0x0b, 0x00, 0x00,
    0x08, 0xca, 0xfe, 0xbe, 0xef, 0x12, 0x34, 0x56,		    0x08, 0xca, 0xfe, 0xbe, 0xef, 0x12, 0x34, 0x56,
    0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,		    0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7b, 0x94, 0x60, 0x0f };					    0x7b, 0x94, 0x60, 0x0f };
  eth_send_raw_packet(raw_test_pkt, 68); //sizeof(reg_idx) + 	  eth_send_raw_packet(raw_test_pkt, 68); //sizeof(reg_idx) + 
  */								  */
}								}

uint_fast8_t enetRX()					      |	uint_fast8_t enet_process_rx_ring()
{								{
  uint_fast8_t num_pkts_rx = 0;					  uint_fast8_t num_pkts_rx = 0;
  while (g_eth_rxpool_ptrs_wpos != g_eth_rxpool_ptrs_rpos)	  while (g_eth_rxpool_ptrs_wpos != g_eth_rxpool_ptrs_rpos)
  {								  {
    const uint16_t rp = g_eth_rxpool_ptrs_rpos;			    const uint16_t rp = g_eth_rxpool_ptrs_rpos;
    const uint8_t *start = (const uint8_t *)g_eth_rxpool_star	    const uint8_t *start = (const uint8_t *)g_eth_rxpool_star
    const uint16_t len = g_eth_rxpool_len[rp];			    const uint16_t len = g_eth_rxpool_len[rp];
    const eth_eth_header_t *e = (const eth_eth_header_t *)sta <
    uint8_t unicast_match = 1;				      <
    uint8_t multicast_match = 1;			      <
    uint8_t broadcast_match = 1;			      <
    							      <
    //printf("eth rxpool wpos = %d rpos = %d start %d len %d\	    //printf("eth rxpool wpos = %d rpos = %d start %d len %d\
    //       g_eth_rxpool_ptrs_wpos,				    //       g_eth_rxpool_ptrs_wpos,
    //       rp, start - g_eth_rxpool, len);			    //       rp, start - g_eth_rxpool, len);
    // see if it's addressed to us				    // see if it's addressed to us
    							      |	    const eth_eth_header_t *e = (const eth_eth_header_t *)sta
							      >	    uint8_t unicast_match = 1, multicast_match = 1, broadcast
    /*								    /*
    printf("rx mac: %02x:%02x:%02x:%02x:%02x:%02x\r\n",		    printf("rx mac: %02x:%02x:%02x:%02x:%02x:%02x\r\n",
           e->dest_addr[0], e->dest_addr[1], e->dest_addr[2],	           e->dest_addr[0], e->dest_addr[1], e->dest_addr[2],
           e->dest_addr[3], e->dest_addr[4], e->dest_addr[5])	           e->dest_addr[3], e->dest_addr[4], e->dest_addr[5])
    */								    */
    for (int i = 0; i < 6; i++)					    for (int i = 0; i < 6; i++)
    {								    {
      if (e->dest_addr[i] != g_eth_src_mac[i])			      if (e->dest_addr[i] != g_eth_src_mac[i])
        unicast_match = 0;					        unicast_match = 0;
      if (e->dest_addr[i] != 0xff)				      if (e->dest_addr[i] != 0xff)
        broadcast_match = 0;					        broadcast_match = 0;
    }								    }
    if (e->dest_addr[0] != 0x01 || e->dest_addr[1] != 0x00 || |	    if (e->dest_addr[0] != 0x01 ||
							      >	        e->dest_addr[1] != 0x00 ||
							      >	        e->dest_addr[2] != 0x5e)
      multicast_match = 0;					      multicast_match = 0;
    //printf("  ucast_match = %d, bcast_match = %d, mcast_mat	    //printf("  ucast_match = %d, bcast_match = %d, mcast_mat
    //       unicast_match, broadcast_match, multicast_match)	    //       unicast_match, broadcast_match, multicast_match)
    //printf("dispatch @ %8u\r\n", (unsigned)SYSTIME);		    //printf("dispatch @ %8u\r\n", (unsigned)SYSTIME);
    if (unicast_match || multicast_match || broadcast_match)	    if (unicast_match || multicast_match || broadcast_match)
      num_pkts_rx += eth_dispatch_eth(start, len) ? 1 : 0;	      num_pkts_rx += eth_dispatch_eth(start, len) ? 1 : 0;
    if (++g_eth_rxpool_ptrs_rpos >= ETH_RAM_RXPOOL_NPTR)	    if (++g_eth_rxpool_ptrs_rpos >= ETH_RAM_RXPOOL_NPTR)
      g_eth_rxpool_ptrs_rpos = 0;				      g_eth_rxpool_ptrs_rpos = 0;
  }								  }
  return num_pkts_rx;						  return num_pkts_rx;
}								}

bool eth_dispatch_eth(const uint8_t *data, const uint16_t len |	static bool eth_dispatch_eth(const uint8_t *data, const uint1
{								{
  // dispatch according to protocol				  // dispatch according to protocol
  const eth_eth_header_t *e = (const eth_eth_header_t *)data;	  const eth_eth_header_t *e = (const eth_eth_header_t *)data;
  switch (eth_htons(e->ethertype))				  switch (eth_htons(e->ethertype))
  {								  {
    case ETH_ETHERTYPE_IP:					    case ETH_ETHERTYPE_IP:
      return eth_dispatch_ip(data, len);			      return eth_dispatch_ip(data, len);
    default:							    default:
      return false;						      return false;
  }								  }
}								}

bool eth_dispatch_ip(const uint8_t *data, const uint16_t len) |	static bool eth_dispatch_ip(const uint8_t *data, const uint16
{								{
  const eth_ip_header_t *ip = (const eth_ip_header_t *)data;	  const eth_ip_header_t *ip = (const eth_ip_header_t *)data;
  if (ip->version != 4) // we only handle ipv4 (for now...)	  if (ip->version != 4) // we only handle ipv4 (for now...)
    return false;						    return false;
  // if it's unicast, verify our IP address, otherwise ignore	  // if it's unicast, verify our IP address, otherwise ignore
  if (ip->eth.dest_addr[0] == g_eth_src_mac[0])			  if (ip->eth.dest_addr[0] == g_eth_src_mac[0])
    if (ip->source_addr != eth_htonl(g_eth_src_ip))		    if (ip->source_addr != eth_htonl(g_eth_src_ip))
      return false;						      return false;
  if (ip->proto == ETH_IP_PROTO_UDP)				  if (ip->proto == ETH_IP_PROTO_UDP)
    return eth_dispatch_udp(data, len);				    return eth_dispatch_udp(data, len);
  return false; // if we get here, we aren't smart enough to 	  return false; // if we get here, we aren't smart enough to 
}								}

bool eth_dispatch_udp(const uint8_t *data, const uint16_t len |	static bool eth_dispatch_udp(const uint8_t *data, const uint1
{								{
  const eth_udp_header_t *udp = (const eth_udp_header_t *)dat	  const eth_udp_header_t *udp = (const eth_udp_header_t *)dat
  const uint16_t port = eth_htons(udp->dest_port);		  const uint16_t port = eth_htons(udp->dest_port);
  const uint16_t payload_len = eth_htons(udp->len) - 8;		  const uint16_t payload_len = eth_htons(udp->len) - 8;
  const uint8_t *payload = data + sizeof(eth_udp_header_t);	  const uint8_t *payload = data + sizeof(eth_udp_header_t);
  //printf("  udp len: %d\r\n", udp_payload_len);		  //printf("  udp len: %d\r\n", udp_payload_len);
  if (payload_len > len - sizeof(eth_udp_header_t))		  if (payload_len > len - sizeof(eth_udp_header_t))
    return false; // ignore fragmented UDP packets.		    return false; // ignore fragmented UDP packets.
  //printf("dispatch udp @ %8u\r\n", (unsigned)SYSTIME);	  //printf("dispatch udp @ %8u\r\n", (unsigned)SYSTIME);

  //printf("dispatch udp: port = %d  payload_len = %d\r\n", p	  //printf("dispatch udp: port = %d  payload_len = %d\r\n", p
  /*								  /*
  for (int i = 0; i < payload_len; i++)				  for (int i = 0; i < payload_len; i++)
  {								  {
    printf("  %02d: %02x\r\n", i, payload[i]);			    printf("  %02d: %02x\r\n", i, payload[i]);
  }								  }
  */								  */
  if (port == 11333 && payload_len > 0)				  if (port == 11333 && payload_len > 0)
  {								  {
    const uint8_t cmd = payload[0];				    const uint8_t cmd = payload[0];
    //printf("  enet rx cmd = 0x%02x\r\n", cmd);		    //printf("  enet rx cmd = 0x%02x\r\n", cmd);
    if (cmd == 0) // CORRECT				      |	    if (cmd == 1 && payload_len >= 5)
    {							      <
      printf("Received printStatusCommand...\n");	      <
							      <
    }							      <
    else if (cmd == 1 && payload_len >= 5)		      <
    {								    {
      /*							      /*
      printf("    modes: %d %d %d %d\r\n",			      printf("    modes: %d %d %d %d\r\n",
             payload[1], payload[2], payload[3], payload[4]);	             payload[1], payload[2], payload[3], payload[4]);
      */							      */
      for (int i = 0; i < NUM_DMXL; i++)			      for (int i = 0; i < NUM_DMXL; i++)
        dmxl_set_control_mode(i, (dmxl_control_mode_t)payload	        dmxl_set_control_mode(i, (dmxl_control_mode_t)payload
      delay_ms(1); // be sure they control mode messages get 	      delay_ms(1); // be sure they control mode messages get 
      return true;						      return true;
    }								    }
    else if (cmd == 2 && payload_len >= 9)			    else if (cmd == 2 && payload_len >= 9)
    {								    {
      uint16_t targets[NUM_DMXL];				      uint16_t targets[NUM_DMXL];
      for (int i = 0; i < NUM_DMXL; i++)			      for (int i = 0; i < NUM_DMXL; i++)
        targets[i] = (payload[1+2*i] << 8) | payload[2+2*i];	        targets[i] = (payload[1+2*i] << 8) | payload[2+2*i];
      /*							      /*
      printf("targets: %06d %06d %06d %06d\r\n",		      printf("targets: %06d %06d %06d %06d\r\n",
             targets[0], targets[1], targets[2], targets[3]);	             targets[0], targets[1], targets[2], targets[3]);
      */							      */
      /*							      /*
      for (int i = 0; i < NUM_DMXL; i++)			      for (int i = 0; i < NUM_DMXL; i++)
        dmxl_set_control_target(i, targets[i]);			        dmxl_set_control_target(i, targets[i]);
      */							      */
      dmxl_set_all_control_targets(targets);			      dmxl_set_all_control_targets(targets);
      //dmxl_set_control_target(0, targets[0]); // debugging.	      //dmxl_set_control_target(0, targets[0]); // debugging.
      return true;						      return true;
    }								    }
  }								  }
  // if we get here, we haven't handled this packet		  // if we get here, we haven't handled this packet
  return false;							  return false;
}								}

// todo: be smarter about multicast group choice		// todo: be smarter about multicast group choice
#define MCAST_IP 0xe000007c					#define MCAST_IP 0xe000007c
#define MCAST_IP 0xe000007c				      <

void enetTX()						      |	void enet_send_state()
{								{
  volatile state_t tx_state = handState; // make a local copy |	  volatile state_t tx_state = g_state; // make a local copy t
  enet_send_udp_mcast(MCAST_IP, 11333, (uint8_t *)&tx_state,  |	  enet_send_udp_mcast(MCAST_IP, 11333,
							      |	                      (uint8_t *)&tx_state, sizeof(tx_state))
  // if ... // CORRECT, this is to send debug information via <
  // volatile state_t tx_status = handStatus; // make a local <
  // enet_send_udp_mcast(MCAST_IP, 11333, (uint8_t *)&tx_stat <
}								}

void ethernetService(void)				      <
{							      <
  if (enet_get_link_status() == ENET_LINK_UP)		      <
  {							      <
    err_unset(ERR_NO_ETHERNET);				      <
    enetTX();						      <
  }							      <
  else							      <
  {							      <
    err_set(ERR_NO_ETHERNET);				      <
  }							      <
  enetRX();						      <
}							      <diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/enet.h /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/enet.h
#ifndef ENET_H							#ifndef ENET_H
#define ENET_H							#define ENET_H

#include <stdint.h>						#include <stdint.h>
#include "stm32f4xx.h"					      <
#include <stdio.h>					      <
#include <string.h>					      <
#include "error.h"					      <
#include "state.h"					      <
#include "systime.h"					      <
#include "delay.h"					      <
#include <stdbool.h>					      <
#include <dmxl.h>					      <
							      <
// declare the pin numbers				      <
#define PORTA_ETH_REFCLK 1				      <
#define PORTA_ETH_MDIO   2				      <
#define PORTA_ETH_CRSDV  7				      <
#define PORTB_ETH_TXEN   11				      <
#define PORTB_ETH_TXD0   12				      <
#define PORTB_ETH_TXD1   13				      <
#define PORTB_PHY_RESET  14				      <
#define PORTC_ETH_MDC    1				      <
#define PORTC_ETH_RXD0   4				      <
#define PORTC_ETH_RXD1   5				      <
							      <
// address is hard-wired on board using internal chip pullups <
#define ENET_PHY_ADDR 0x01				      <
							      <
#define ETH_NBUF 2048					      <
#define ETH_DMA_NRXD 16					      <
#define ETH_DMA_NTXD  4					      <
							      <
typedef struct						      <
{							      <
  uint32_t des0;					      <
  uint32_t des1;					      <
  uint32_t des2;					      <
  uint32_t des3;					      <
} eth_dma_desc_t;					      <
							      <
#define ALIGN4 __attribute__((aligned(4)));		      <
							      <
#define ETH_RAM_RXPOOL_LEN  16384			      <
#define ETH_RAM_RXPOOL_NPTR   128			      <
							      <
///////////////////////////////////////////////////////////// <
// local functions					      <
void eth_send_raw_packet(uint8_t *pkt, uint16_t pkt_len); //  <
bool eth_dispatch_eth(const uint8_t *data, const uint16_t len <
bool eth_dispatch_ip(const uint8_t *data, const uint16_t len) <
bool eth_dispatch_udp(const uint8_t *data, const uint16_t len <
							      <
///////////////////////////////////////////////////////////// <

void enet_init();						void enet_init();

typedef enum { ENET_LINK_DOWN, ENET_LINK_UP } enet_link_statu	typedef enum { ENET_LINK_DOWN, ENET_LINK_UP } enet_link_statu
enet_link_status_t enet_get_link_status();			enet_link_status_t enet_get_link_status();

void enet_send_udp_ucast(const uint8_t *dest_mac,		void enet_send_udp_ucast(const uint8_t *dest_mac,
                           const uint32_t dest_ip, const uint	                           const uint32_t dest_ip, const uint
                           const uint32_t source_ip, const ui	                           const uint32_t source_ip, const ui
                           const uint8_t *payload, const uint	                           const uint8_t *payload, const uint

void enet_send_udp_mcast(const uint32_t mcast_ip, const uint1	void enet_send_udp_mcast(const uint32_t mcast_ip, const uint1
                         const uint8_t *payload, const uint16	                         const uint8_t *payload, const uint16

void enet_write_phy_reg(const uint8_t reg_idx, const uint16_t	void enet_write_phy_reg(const uint8_t reg_idx, const uint16_t

uint_fast8_t enetRX(void);				      |	uint_fast8_t enet_process_rx_ring();
void enetTX(void);					      |
void ethernetService(void);				      |	void enet_send_state();
							      >
#endif								#endif

diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/error.c /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/error.c
#include "error.h"						#include "error.h"
#include "leds.h"						#include "leds.h"
#include "systime.h"						#include "systime.h"
#include <stdbool.h>						#include <stdbool.h>

#define NUM_LEDs  4						#define NUM_LEDs  4
#define NUM_FLASHES 8						#define NUM_FLASHES 8

// A quarter second delay between flashes means 8 flashes is 	// A quarter second delay between flashes means 8 flashes is 
static const uint32_t FLASH_INTERVAL_US = 250000;		static const uint32_t FLASH_INTERVAL_US = 250000;
// Here are the pattern of lights used to indicate the variou	// Here are the pattern of lights used to indicate the variou
static const uint8_t errSequence[ERR_NUMBER][NUM_FLASHES] = {	static const uint8_t errSequence[ERR_NUMBER][NUM_FLASHES] = {
  {0b1000, 0b0100, 0b0010, 0b0001, 0, 0, 0, 0}, // No Etherne	  {0b1000, 0b0100, 0b0010, 0b0001, 0, 0, 0, 0}, // No Etherne
  {0b1000, 0b0100, 0b0001, 0b0010, 0, 0, 0, 0}, // Ethernet b	  {0b1000, 0b0100, 0b0001, 0b0010, 0, 0, 0, 0}, // Ethernet b
  {0b1000, 0b0010, 0b0100, 0b0001, 0, 0, 0, 0}, // Ethernet p	  {0b1000, 0b0010, 0b0100, 0b0001, 0, 0, 0, 0}, // Ethernet p
  {0b1000, 0b0010, 0b0001, 0b0100, 0, 0, 0, 0}, // Ethernet a	  {0b1000, 0b0010, 0b0001, 0b0100, 0, 0, 0, 0}, // Ethernet a
  {0b0100, 0b1000, 0b0000, 0b1110, 0, 0, 0, 0}, // Encoders a	  {0b0100, 0b1000, 0b0000, 0b1110, 0, 0, 0, 0}, // Encoders a
  {0b0100, 0b1000, 0b0000, 0b1000, 0, 0, 0, 0}, // Encoder 1 	  {0b0100, 0b1000, 0b0000, 0b1000, 0, 0, 0, 0}, // Encoder 1 
  {0b0100, 0b1000, 0b0000, 0b0100, 0, 0, 0, 0}, // Encoder 2 	  {0b0100, 0b1000, 0b0000, 0b0100, 0, 0, 0, 0}, // Encoder 2 
  {0b0100, 0b1000, 0b0000, 0b0010, 0, 0, 0, 0}, // Encoder 3 	  {0b0100, 0b1000, 0b0000, 0b0010, 0, 0, 0, 0}, // Encoder 3 
  {0b0100, 0b0010, 0b0000, 0b1000, 0, 0, 0, 0}, // I2C error 	  {0b0100, 0b0010, 0b0000, 0b1000, 0, 0, 0, 0}, // I2C error 
  {0b0100, 0b0010, 0b0000, 0b0100, 0, 0, 0, 0}, // I2C error 	  {0b0100, 0b0010, 0b0000, 0b0100, 0, 0, 0, 0}, // I2C error 
  {0b0100, 0b0010, 0b0000, 0b0010, 0, 0, 0, 0}, // I2C error 	  {0b0100, 0b0010, 0b0000, 0b0010, 0, 0, 0, 0}, // I2C error 
  {0b0100, 0b0010, 0b0000, 0b0001, 0, 0, 0, 0}  // I2C error 	  {0b0100, 0b0010, 0b0000, 0b0001, 0, 0, 0, 0}  // I2C error 
  };								  };

// Which errors have been recorded				// Which errors have been recorded
static uint8_t errDetected[ERR_NUMBER] = {0};			static uint8_t errDetected[ERR_NUMBER] = {0};


// Displays the appropriate LED pattern for a given error at 	// Displays the appropriate LED pattern for a given error at 
// sequence							// sequence
void setLEDs(uint8_t errorIndex, uint8_t flashIndex) {		void setLEDs(uint8_t errorIndex, uint8_t flashIndex) {
  uint8_t pattern = errSequence[errorIndex][flashIndex];	  uint8_t pattern = errSequence[errorIndex][flashIndex];
  for (int i = 0; i < NUM_LEDs; i++) {				  for (int i = 0; i < NUM_LEDs; i++) {
    if (pattern & (1 << i)) {					    if (pattern & (1 << i)) {
      leds_on(i);						      leds_on(i);
    } else {							    } else {
      leds_off(i);						      leds_off(i);
    }								    }
  }								  }
}								}

// This displays the error codes one by one. Each dispay is m	// This displays the error codes one by one. Each dispay is m
// "flashes" of LED patterns over the first second of the dis	// "flashes" of LED patterns over the first second of the dis
// in the second second of the display				// in the second second of the display
void errorService() {					      |	void err_service() {
  // Shows that we've started a pattern of flashes and will c	  // Shows that we've started a pattern of flashes and will c
  // finish it							  // finish it
  static bool displaying = false;				  static bool displaying = false;
  // The index of the error we are checking and possibly disp	  // The index of the error we are checking and possibly disp
  static uint8_t errorIndex = 0;				  static uint8_t errorIndex = 0;
  // Which flash [0-7] of the LEDs we're currently displaying	  // Which flash [0-7] of the LEDs we're currently displaying
  static uint8_t flashIndex = 0;				  static uint8_t flashIndex = 0;
  // The time (in uS) when the current flash started.		  // The time (in uS) when the current flash started.
  static uint32_t flashStartTime = 0;				  static uint32_t flashStartTime = 0;

  // err_set(ERR_TAC_0_PROBLEM + takktile_port);	      <

  // We should continue with our current display		  // We should continue with our current display
  if (displaying)					      |	  if (displaying) {
  {							      |	    if (SYSTIME - flashStartTime < FLASH_INTERVAL_US) {
    if (SYSTIME - flashStartTime < FLASH_INTERVAL_US)	      <
    {							      <
      return;							      return;
    }								    }

    flashStartTime = SYSTIME;					    flashStartTime = SYSTIME;
    flashIndex++;						    flashIndex++;
    if (flashIndex < NUM_FLASHES)			      |	    if (flashIndex < NUM_FLASHES) {
    {							      <
      setLEDs(errorIndex, flashIndex);				      setLEDs(errorIndex, flashIndex);
      return;							      return;
    }								    }

    // If all are stuck we don't need to then display each in	    // If all are stuck we don't need to then display each in
    if (errorIndex == ERR_ENC_ALL_STUCK)		      |	    if (errorIndex == ERR_ENC_ALL_STUCK) {
    {							      <
      errorIndex += 4;						      errorIndex += 4;
    }							      |	    } else {
    else						      <
    {							      <
      errorIndex++;						      errorIndex++;
    }								    }
    errorIndex %= ERR_NUMBER;					    errorIndex %= ERR_NUMBER;
    displaying = false;						    displaying = false;
    return;							    return;
  }								  }

  // If we've found a new error start displaying it		  // If we've found a new error start displaying it
  if (errDetected[errorIndex])				      |	  if (errDetected[errorIndex]) {
  {							      <
    displaying = true;						    displaying = true;
    flashIndex = 0;						    flashIndex = 0;
    flashStartTime = SYSTIME;					    flashStartTime = SYSTIME;
    setLEDs(errorIndex, flashIndex);				    setLEDs(errorIndex, flashIndex);
    return;							    return;
  }								  }
							      >
  // Otherwise keep cycling and looking for an error		  // Otherwise keep cycling and looking for an error
  else							      |	  errorIndex++;
  {							      |	  errorIndex %= ERR_NUMBER;
    errorIndex++;					      <
    errorIndex %= ERR_NUMBER;				      <
  }							      <
  return;							  return;
}								}

void err_set(error_type_t err) {				void err_set(error_type_t err) {
  errDetected[err] = 1;						  errDetected[err] = 1;
}								}

void err_unset(error_type_t err) {				void err_unset(error_type_t err) {
  errDetected[err] = 0;						  errDetected[err] = 0;
}								}
diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/error.h /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/error.h
#ifndef ERROR_H							#ifndef ERROR_H
#define ERROR_H							#define ERROR_H

#include <stdint.h>						#include <stdint.h>

typedef enum							typedef enum
{								{
  ERR_NO_ETHERNET,     // No ethernet				  ERR_NO_ETHERNET,     // No ethernet
  ERR_ETH_BUFFER_FULL, // The on-chip buffer for ethernet mes	  ERR_ETH_BUFFER_FULL, // The on-chip buffer for ethernet mes
  ERR_ETH_REMOTE_FAULT,// The PHY detected a remote fault con	  ERR_ETH_REMOTE_FAULT,// The PHY detected a remote fault con
  ERR_ETH_NEGOTIATING, // The ethernet connection is being au	  ERR_ETH_NEGOTIATING, // The ethernet connection is being au
  ERR_ENC_ALL_STUCK,   // All 3 encoders have repeated the sa	  ERR_ENC_ALL_STUCK,   // All 3 encoders have repeated the sa
  ERR_ENC_1_STUCK,     // Encoder 1 has repeated it's value	  ERR_ENC_1_STUCK,     // Encoder 1 has repeated it's value
  ERR_ENC_2_STUCK,     // Encoder 2 has repeated it's value	  ERR_ENC_2_STUCK,     // Encoder 2 has repeated it's value
  ERR_ENC_3_STUCK,     // Encoder 3 has repeated it's value	  ERR_ENC_3_STUCK,     // Encoder 3 has repeated it's value
  ERR_TAC_0_PROBLEM,   // i2c communication error with tactil	  ERR_TAC_0_PROBLEM,   // i2c communication error with tactil
  ERR_TAC_1_PROBLEM,   // i2c communication error with tactil	  ERR_TAC_1_PROBLEM,   // i2c communication error with tactil
  ERR_TAC_2_PROBLEM,   // i2c communication error with tactil	  ERR_TAC_2_PROBLEM,   // i2c communication error with tactil
  ERR_TAC_3_PROBLEM,   // i2c communication error with tactil	  ERR_TAC_3_PROBLEM,   // i2c communication error with tactil
  ERR_NUMBER           // Placeholder to give us the number o	  ERR_NUMBER           // Placeholder to give us the number o
} error_type_t;							} error_type_t;

// **NOTE** Always make sure you can clear any condition you 	// **NOTE** Always make sure you can clear any condition you 
void err_set(error_type_t err); // Start displaying the speci	void err_set(error_type_t err); // Start displaying the speci
void err_unset(error_type_t err); // Stop displaying the spec	void err_unset(error_type_t err); // Stop displaying the spec
void errorService(); // Service the LED error mechanism causi |	void err_service(); // Service the LED error mechanism causin

#endif								#endif

diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/fan.c /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/fan.c
#include "fan.h"						#include "fan.h"
#include "./stm32/stm32f4xx.h"				      |	#include "stm32f4xx.h"

#define PORTD_FAN_EN 15						#define PORTD_FAN_EN 15

void fan_init()							void fan_init()
{								{
  RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN;				  RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN;
  GPIOD->MODER |= 1 << (PORTD_FAN_EN * 2); // set as output p	  GPIOD->MODER |= 1 << (PORTD_FAN_EN * 2); // set as output p
}								}

void fan_on()							void fan_on()
{								{
  GPIOD->BSRRL |= 1 << PORTD_FAN_EN;				  GPIOD->BSRRL |= 1 << PORTD_FAN_EN;
}								}

void fan_off()							void fan_off()
{								{
  GPIOD->BSRRH |= 1 << PORTD_FAN_EN;				  GPIOD->BSRRH |= 1 << PORTD_FAN_EN;
}								}

diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/fan.h /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/fan.h
#ifndef FAN_H							#ifndef FAN_H
#define FAN_H							#define FAN_H

void fan_init();						void fan_init();
void fan_on();							void fan_on();
void fan_off();							void fan_off();

#endif								#endif

Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: i2cFunc (beforeCleaningTimeout).c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: i2cFunc.c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: i2cFunc.h
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: imu (backup, no multiplexer).c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: imu (backup, no multiplexer).h
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: imu (backup, using multipler).c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: imu.c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: imu.h
diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/leds.c /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/leds.c
#include "leds.h"						#include "leds.h"
#include "./stm32/stm32f4xx.h"				      |	#include "stm32f4xx.h"
#include <stdio.h>						#include <stdio.h>

#define PORTE_LED0 3						#define PORTE_LED0 3
#define PORTE_LED1 4						#define PORTE_LED1 4
#define PORTB_LED2 10						#define PORTB_LED2 10
#define PORTE_LED3 15						#define PORTE_LED3 15

void leds_init()						void leds_init()
{								{
  RCC->AHB1ENR   |= RCC_AHB1ENR_GPIOEEN;			  RCC->AHB1ENR   |= RCC_AHB1ENR_GPIOEEN;
  GPIOE->MODER   |= (1 << (PORTE_LED0 * 2)) |			  GPIOE->MODER   |= (1 << (PORTE_LED0 * 2)) |
                    (1 << (PORTE_LED1 * 2)) |			                    (1 << (PORTE_LED1 * 2)) |
                    (1 << (PORTE_LED3 * 2));			                    (1 << (PORTE_LED3 * 2));

  RCC->AHB1ENR   |= RCC_AHB1ENR_GPIOBEN;			  RCC->AHB1ENR   |= RCC_AHB1ENR_GPIOBEN;
  GPIOB->MODER   |= (1 << (PORTB_LED2 * 2));			  GPIOB->MODER   |= (1 << (PORTB_LED2 * 2));
}								}

void leds_on(uint8_t led)					void leds_on(uint8_t led)
{								{
  if (led == 0)							  if (led == 0)
    GPIOE->BSRRL = 1 << PORTE_LED0;				    GPIOE->BSRRL = 1 << PORTE_LED0;
  else if (led == 1)						  else if (led == 1)
    GPIOE->BSRRL = 1 << PORTE_LED1;				    GPIOE->BSRRL = 1 << PORTE_LED1;
  else if (led == 2)						  else if (led == 2)
    GPIOB->BSRRL = 1 << PORTB_LED2;				    GPIOB->BSRRL = 1 << PORTB_LED2;
  else if (led == 3)						  else if (led == 3)
    GPIOE->BSRRL = 1 << PORTE_LED3;				    GPIOE->BSRRL = 1 << PORTE_LED3;
  else								  else
    printf("LED %d does not exist\n", led);			    printf("LED %d does not exist\n", led);
}								}

void leds_off(uint8_t led)					void leds_off(uint8_t led)
{								{
  if (led == 0)							  if (led == 0)
    GPIOE->BSRRH = 1 << PORTE_LED0;				    GPIOE->BSRRH = 1 << PORTE_LED0;
  else if (led == 1)						  else if (led == 1)
    GPIOE->BSRRH = 1 << PORTE_LED1;				    GPIOE->BSRRH = 1 << PORTE_LED1;
  else if (led == 2)						  else if (led == 2)
    GPIOB->BSRRH = 1 << PORTB_LED2;				    GPIOB->BSRRH = 1 << PORTB_LED2;
  else if (led == 3)						  else if (led == 3)
    GPIOE->BSRRH = 1 << PORTE_LED3;				    GPIOE->BSRRH = 1 << PORTE_LED3;
  else								  else
    printf("LED %d does not exist\n", led);			    printf("LED %d does not exist\n", led);
}								}

void leds_toggle(uint8_t led)					void leds_toggle(uint8_t led)
{								{
  if (led == 0)							  if (led == 0)
    GPIOE->ODR ^= 1 << PORTE_LED0;				    GPIOE->ODR ^= 1 << PORTE_LED0;
  else if (led == 1)						  else if (led == 1)
    GPIOE->ODR ^= 1 << PORTE_LED1;				    GPIOE->ODR ^= 1 << PORTE_LED1;
  else if (led == 2)						  else if (led == 2)
    GPIOB->ODR ^= 1 << PORTB_LED2;				    GPIOB->ODR ^= 1 << PORTB_LED2;
  else if (led == 3)						  else if (led == 3)
    GPIOE->ODR ^= 1 << PORTE_LED3;				    GPIOE->ODR ^= 1 << PORTE_LED3;
  else								  else
    printf("LED %d does not exist\n", led);			    printf("LED %d does not exist\n", led);
}								}

diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/leds.h /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/leds.h
#ifndef LEDS_H							#ifndef LEDS_H
#define LEDS_H							#define LEDS_H

#include <stdint.h>						#include <stdint.h>

void leds_init();						void leds_init();
void leds_on(uint8_t led_idx);					void leds_on(uint8_t led_idx);
void leds_off(uint8_t led_idx);					void leds_off(uint8_t led_idx);
void leds_toggle(uint8_t led_idx);				void leds_toggle(uint8_t led_idx);

#endif								#endif

Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: main (blink and serial).c
diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/main.c /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/main.c
#include "config.h"					      |	#include "leds.h"
							      |	#include "error.h"
/* UART DEBUGGING					      |	#include "console.h"
*     Go to the file stubs.c and change the following line:   |	#include "enet.h"
*							      |	#include <stdio.h>
*     #define DEBUG_VIA_UART true			      |	#include "systime.h"
*							      |	#include "dmxl.h"
*     true if you want to debug via UART, using the 4 pins on |	#include "fan.h"
*     false, if you want a faster normal functioning	      |	#include "tactile.h"
*/							      |	#include "enc.h"
							      >	#include "state.h"
							      >	#include "async_poll.h"

							      >	//#define PRINT_TIMING

int main()							int main()
{								{
  init();						      |	  console_init();
  printf("Starting operation...\n");			      |	  systime_init();
  while(1)						      |	  printf("=== RESET ===\r\n");
  {							      |	  leds_init();
    errorService();					      |	  enet_init();
							      >	  dmxl_init();
							      >	  fan_init();
							      >	  tactile_init();
							      >	  enc_init();
							      >	  state_init();
							      >	  async_poll_init();
							      >	  printf("init complete; entering main loop.\r\n");
							      >	  fan_on(); // todo: be smarter. probably doesn't need to run
							      >	  __enable_irq();
							      >
							      >	  dmxl_set_baud_rates();
							      >	  dmxl_set_status_return_levels();

    if (asyncUpdate())					      |	  volatile uint32_t prev_start_time = SYSTIME;
							      >	  //#define POLL_PERIOD_US 33333
							      >	  #define POLL_PERIOD_US 25000
							      >	  uint_fast8_t poll_cycles_to_skip = 0;
							      >
							      >	  for (uint_fast32_t loop_count = 1; ; loop_count++)
							      >	  {
							      >	    err_service();
							      >	    if (SYSTIME - prev_start_time >= POLL_PERIOD_US)
    {								    {
      printInfo(HAND_STATE_INFO);			      |	      prev_start_time += POLL_PERIOD_US;
      // printf("All done, send via ethernet...\n");	      |	      if (poll_cycles_to_skip > 0)
      ethernetService();				      |	        poll_cycles_to_skip--;
    }    						      |	      else
							      >	      {
							      >	        g_state.systime = SYSTIME;
							      >	        async_poll_start();
							      >	      }
							      >	    }
							      >	    const async_poll_tick_result_t aptr = async_poll_tick();
							      >	    if (aptr == APT_JUST_FINISHED)
							      >	    {
							      >	#ifdef PRINT_TIMING
							      >	      volatile uint32_t t1 __attribute__((unused))= SYSTIME -
							      >	      printf("%lu : %lu \r\n", SYSTIME, t1);
							      >	#endif
							      >	      if (enet_get_link_status() == ENET_LINK_UP) {
							      >	        err_unset(ERR_NO_ETHERNET);
							      >	        enet_send_state();
							      >	      } else {
							      >	        err_set(ERR_NO_ETHERNET);
							      >	      }
							      >
							      >	      enet_process_rx_ring();
							      >	#if 0
							      >
							      >	#ifdef PRINT_TIMING
							      >	      volatile uint32_t t_before_enet = SYSTIME;
							      >	#endif
							      >	      uint_fast8_t num_rx = enet_process_rx_ring();
							      >	#ifdef PRINT_TIMING
							      >	      volatile uint32_t t_after_enet = SYSTIME;
							      >	#endif
							      >	      if (num_rx) // most inbound messages require dmxl tx/rx
							      >	      {
							      >	        // if we did something with a packet, bump our next T
							      >	        // by one cycle period, so we have enough time to tal
							      >	        // dynamixels
							      >	        //poll_cycles_to_skip = 1; // skip the next polling c
							      >	        //printf("proc rx ring: %d\r\n", num_rx);
							      >	#ifdef PRINT_TIMING
							      >	        volatile uint32_t t_before_dmxl = SYSTIME;
							      >	#endif
							      >	        dmxl_process_rings();
							      >	#ifdef PRINT_TIMING
							      >	        volatile uint32_t t_after_dmxl = SYSTIME;
							      >	        printf("%8u %8u %8u %8u\r\n",
							      >	               (unsigned)t_before_enet,
							      >	               (unsigned)t_after_enet,
							      >	               (unsigned)t_before_dmxl,
							      >	               (unsigned)t_after_dmxl);
							      >	#endif
							      >	      }
							      >	#endif
							      >	    }
  }								  }
  return 0;							  return 0;
}								}
							      >
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: main (original).c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: main (pressures).c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: main (read hexadecimal).c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: main (single takktile read).c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: main (testing imu standalone).c
diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/Makefile /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/Makefile
BINDIR=bin							BINDIR=bin
NAME=reflex							NAME=reflex
OUT=$(BINDIR)/$(NAME)						OUT=$(BINDIR)/$(NAME)
FLOAT_FLAGS=-mfloat-abi=hard -mfpu=fpv4-sp-d16			FLOAT_FLAGS=-mfloat-abi=hard -mfpu=fpv4-sp-d16
OPENOCD=../tools/openocd/bin/openocd				OPENOCD=../tools/openocd/bin/openocd
CFLAGS=$(DEFS) -O2 -g $(FLOAT_FLAGS) -mthumb -mcpu=cortex-m4 	CFLAGS=$(DEFS) -O2 -g $(FLOAT_FLAGS) -mthumb -mcpu=cortex-m4 
LDFLAGS=-g $(FLOAT_FLAGS) -mthumb -mcpu=cortex-m4		LDFLAGS=-g $(FLOAT_FLAGS) -mthumb -mcpu=cortex-m4
TC=arm-none-eabi-						TC=arm-none-eabi-
CC=$(TC)gcc							CC=$(TC)gcc
							      <
SRCS=main.c imu.c ports.c config.c startup.c i2cFunc.c spiFun <
     takktile.c pin.c enc.c state.c async_poll.c delay.c erro <
							      <
							      <
DEPS=i2cFunc.h spiFunc.h imu.h ports.h leds.h console.h enet. <

							      >	SRCS=startup.c main.c leds.c console.c stubs.c enet.c systime
							      >	     tactile.c pin.c enc.c state.c async_poll.c delay.c error
OBJS=$(SRCS:%.c=$(BINDIR)/%.o)					OBJS=$(SRCS:%.c=$(BINDIR)/%.o)

default: $(BINDIR) $(OUT).bin					default: $(BINDIR) $(OUT).bin

$(BINDIR):							$(BINDIR):
	mkdir -p $(BINDIR)						mkdir -p $(BINDIR)

$(BINDIR)/%.o: %.c						$(BINDIR)/%.o: %.c
	$(TC)gcc $(CFLAGS) -c $< -o $@					$(TC)gcc $(CFLAGS) -c $< -o $@

$(OUT): $(OBJS) 					      |	$(OUT): $(OBJS)
	$(TC)gcc $(OBJS) -lc -lgcc -lm  -T stm32/stm32f427.ld		$(TC)gcc $(OBJS) -lc -lgcc -lm  -T stm32/stm32f427.ld
	$(TC)objdump -S -d $(OUT) > $(OUT).objdump			$(TC)objdump -S -d $(OUT) > $(OUT).objdump

$(OUT).bin: $(OUT) 					      |	$(OUT).bin: $(OUT)
	$(TC)objcopy -O binary $(OUT) $(OUT).bin			$(TC)objcopy -O binary $(OUT) $(OUT).bin
	$(TC)size $(OUT)						$(TC)size $(OUT)

clean:								clean:
	-rm $(BINDIR)/*							-rm $(BINDIR)/*
	rmdir $(BINDIR)							rmdir $(BINDIR)

dfu_download: $(OUT).bin					dfu_download: $(OUT).bin
	sudo dfu-util -d 0483:df11 --dfuse-address 0x08000000		sudo dfu-util -d 0483:df11 --dfuse-address 0x08000000

program: ${OUT}.bin						program: ${OUT}.bin
	$(OPENOCD) -f stm32/olimex-arm-usb-tiny-h.cfg -f stm3		$(OPENOCD) -f stm32/olimex-arm-usb-tiny-h.cfg -f stm3

dump_flash:							dump_flash:
	$(OPENOCD) -f stm32/olimex-arm-usb-tiny-h.cfg -f stm3		$(OPENOCD) -f stm32/olimex-arm-usb-tiny-h.cfg -f stm3

gdb_server: $(OUT).bin						gdb_server: $(OUT).bin
	$(OPENOCD) -f stm32/olimex-arm-usb-tiny-h.cfg -f stm3		$(OPENOCD) -f stm32/olimex-arm-usb-tiny-h.cfg -f stm3

gdb: $(OUT).bin							gdb: $(OUT).bin
	$(TC)gdb $(OUT) -x stm32/gdb_init_commands			$(TC)gdb $(OUT) -x stm32/gdb_init_commands

reset:								reset:
	$(OPENOCD) -f stm32/olimex-arm-usb-tiny-h.cfg -f stm3		$(OPENOCD) -f stm32/olimex-arm-usb-tiny-h.cfg -f stm3

install_gccarm_on_ubuntu:					install_gccarm_on_ubuntu:
	sudo add-apt-repository ppa:terry.guo/gcc-arm-embedde		sudo add-apt-repository ppa:terry.guo/gcc-arm-embedde
	sudo apt-get update						sudo apt-get update
	sudo apt-get install gcc-arm-none-eabi				sudo apt-get install gcc-arm-none-eabi

diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/pin.c /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/pin.c
#include "./stm32/stm32f4xx.h"				      |	#include "stm32f4xx.h"
#include "pin.h"						#include "pin.h"
#include <stdio.h>						#include <stdio.h>

void pin_set_output_type(GPIO_TypeDef *gpio, 			void pin_set_output_type(GPIO_TypeDef *gpio, 
                         const uint8_t pin_idx,			                         const uint8_t pin_idx,
                         const uint8_t output_type)		                         const uint8_t output_type)
{								{
  if (output_type == PIN_OUTPUT_TYPE_OPEN_DRAIN)		  if (output_type == PIN_OUTPUT_TYPE_OPEN_DRAIN)
  {								  {
    //printf("setting pin %d to open-drain\r\n", pin_idx);	    //printf("setting pin %d to open-drain\r\n", pin_idx);
    gpio->OTYPER |= (1 << pin_idx);				    gpio->OTYPER |= (1 << pin_idx);
  }								  }
  else								  else
  {								  {
    //printf("setting pin %d to push-pull\r\n", pin_idx);	    //printf("setting pin %d to push-pull\r\n", pin_idx);
    gpio->OTYPER &= ~(1 << pin_idx);				    gpio->OTYPER &= ~(1 << pin_idx);
  }								  }
}								}

void pin_set_alternate_function(GPIO_TypeDef *gpio,		void pin_set_alternate_function(GPIO_TypeDef *gpio,
                                const uint8_t pin_idx,		                                const uint8_t pin_idx,
                                const uint8_t function_idx)	                                const uint8_t function_idx)
{								{
  if (pin_idx > 15 || function_idx > 15)			  if (pin_idx > 15 || function_idx > 15)
    return; // adios amigo					    return; // adios amigo
  volatile uint32_t *af_reg = (pin_idx < 8) ? &gpio->AFR[0] :	  volatile uint32_t *af_reg = (pin_idx < 8) ? &gpio->AFR[0] :
  const uint8_t reg_ofs = (pin_idx < 8) ? (pin_idx * 4) : ((p	  const uint8_t reg_ofs = (pin_idx < 8) ? (pin_idx * 4) : ((p
  *af_reg &= ~(0xf << reg_ofs); // zero out whatever was ther	  *af_reg &= ~(0xf << reg_ofs); // zero out whatever was ther
  *af_reg |= function_idx << reg_ofs; // set the alternate fu	  *af_reg |= function_idx << reg_ofs; // set the alternate fu
  gpio->MODER &= ~(3 << (pin_idx * 2)); // zero out whatever 	  gpio->MODER &= ~(3 << (pin_idx * 2)); // zero out whatever 
  gpio->MODER |= 2 << (pin_idx * 2); // put the GPIO in alter	  gpio->MODER |= 2 << (pin_idx * 2); // put the GPIO in alter
}								}

void pin_set_output(GPIO_TypeDef *gpio, const uint8_t pin_idx	void pin_set_output(GPIO_TypeDef *gpio, const uint8_t pin_idx
{								{
  if (pin_idx > 15)						  if (pin_idx > 15)
    return; // adios amigo					    return; // adios amigo
  gpio->MODER &= ~(3 << (pin_idx * 2));				  gpio->MODER &= ~(3 << (pin_idx * 2));
  gpio->MODER |= 1 << (pin_idx * 2);				  gpio->MODER |= 1 << (pin_idx * 2);
}								}

void pin_set_output_level(GPIO_TypeDef *gpio, 			void pin_set_output_level(GPIO_TypeDef *gpio, 
                          const uint8_t pin_idx, 		                          const uint8_t pin_idx, 
                          const uint8_t pin_level)		                          const uint8_t pin_level)
{								{
  if (pin_idx > 15)						  if (pin_idx > 15)
    return;							    return;
  if (pin_level)						  if (pin_level)
    gpio->BSRRL = 1 << pin_idx;					    gpio->BSRRL = 1 << pin_idx;
  else								  else
    gpio->BSRRH = 1 << pin_idx;					    gpio->BSRRH = 1 << pin_idx;
}								}

diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/pin.h /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/pin.h
#ifndef PIN_H							#ifndef PIN_H
#define PIN_H							#define PIN_H

#define PIN_OUTPUT_TYPE_PUSH_PULL  0				#define PIN_OUTPUT_TYPE_PUSH_PULL  0
#define PIN_OUTPUT_TYPE_OPEN_DRAIN 1				#define PIN_OUTPUT_TYPE_OPEN_DRAIN 1

void pin_set_output_type(GPIO_TypeDef *gpio, 			void pin_set_output_type(GPIO_TypeDef *gpio, 
                         const uint8_t pin_idx,			                         const uint8_t pin_idx,
                         const uint8_t output_type);		                         const uint8_t output_type);
void pin_set_alternate_function(GPIO_TypeDef *gpio,		void pin_set_alternate_function(GPIO_TypeDef *gpio,
                                const uint8_t pin_idx,		                                const uint8_t pin_idx,
                                const uint8_t function_idx);	                                const uint8_t function_idx);
void pin_set_output(GPIO_TypeDef *gpio, const uint8_t pin_idx	void pin_set_output(GPIO_TypeDef *gpio, const uint8_t pin_idx
void pin_set_output_level(GPIO_TypeDef *gpio, 			void pin_set_output_level(GPIO_TypeDef *gpio, 
                          const uint8_t pin_idx, 		                          const uint8_t pin_idx, 
                          const uint8_t pin_level);		                          const uint8_t pin_level);

#endif								#endif
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: ports.c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: ports.h
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: README.md
diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/reflex.h /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/reflex.h
#ifndef REFLEX_H					      |	#ifndef HAND_H
#define REFLEX_H					      |	#define HAND_H

#define NUM_FINGERS 3						#define NUM_FINGERS 3
#define SENSORS_PER_FINGER  9				      <
#define NUM_PALM_SENSORS    11				      <
#define NUM_SENSORS         (NUM_FINGERS * SENSORS_PER_FINGER <
#define NUM_ENC 3					      <
#define NUM_IMUS 4					      <

#endif								#endif

Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: sketches
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: spiFuncBackup1.c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: spiFuncBackup2.c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: spiFunc.c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: spiFunc.h
diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/startup.c /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/startup.c
#include <stdint.h>						#include <stdint.h>
#include "./stm32/stm32f4xx.h"				      |	#include "stm32f4xx.h"

extern uint32_t _srelocate_flash, _srelocate, _erelocate, _eb	extern uint32_t _srelocate_flash, _srelocate, _erelocate, _eb
extern int main();						extern int main();

void startup_clock_init_fail() { while (1) { } }		void startup_clock_init_fail() { while (1) { } }

void reset_vector()						void reset_vector()
{								{
  uint32_t *pSrc, *pDest;					  uint32_t *pSrc, *pDest;
  //clock_init();						  //clock_init();
  // slow down the flash					  // slow down the flash
  //EFC0->EEFC_FMR = EEFC_FMR_FWS(1);				  //EFC0->EEFC_FMR = EEFC_FMR_FWS(1);
  //EFC1->EEFC_FMR = EEFC_FMR_FWS(1);				  //EFC1->EEFC_FMR = EEFC_FMR_FWS(1);
  //WDT->WDT_MR = WDT_MR_WDDIS; // disable watchdog for now	  //WDT->WDT_MR = WDT_MR_WDDIS; // disable watchdog for now
  // set up data segment					  // set up data segment
  __disable_irq();						  __disable_irq();
  pSrc = &_srelocate_flash;					  pSrc = &_srelocate_flash;
  pDest = &_srelocate;						  pDest = &_srelocate;
  if (pSrc != pDest)						  if (pSrc != pDest)
    for (; pDest < &_erelocate; )				    for (; pDest < &_erelocate; )
      *pDest++ = *pSrc++;					      *pDest++ = *pSrc++;
  // set up bss segment						  // set up bss segment
  for (pDest = &_sbss; pDest < &_ebss; )			  for (pDest = &_sbss; pDest < &_ebss; )
    *pDest++ = 0;						    *pDest++ = 0;
  //__libc_init_array() ;					  //__libc_init_array() ;
  SCB->CPACR |= ((3UL << (10*2)) | (3UL << (11*2))); // activ	  SCB->CPACR |= ((3UL << (10*2)) | (3UL << (11*2))); // activ
  RCC->CR |= 0x1; // ensure the HSI (internal) oscillator is 	  RCC->CR |= 0x1; // ensure the HSI (internal) oscillator is 
  RCC->CFGR = 0; // ensure the HSI oscillator is the clock so	  RCC->CFGR = 0; // ensure the HSI oscillator is the clock so
  RCC->CR &= 0xfef6ffff; // turn off the main PLL and HSE osc	  RCC->CR &= 0xfef6ffff; // turn off the main PLL and HSE osc
  RCC->PLLCFGR = 0x24003010; // ensure PLLCFGR is at reset st	  RCC->PLLCFGR = 0x24003010; // ensure PLLCFGR is at reset st
  RCC->CR &= 0xfffbffff; // reset HSEBYP (i.e., HSE is *not* 	  RCC->CR &= 0xfffbffff; // reset HSEBYP (i.e., HSE is *not* 
  RCC->CIR = 0x0; // disable all RCC interrupts			  RCC->CIR = 0x0; // disable all RCC interrupts
  RCC->CR |= RCC_CR_HSEON; // enable HSE oscillator (off-chip	  RCC->CR |= RCC_CR_HSEON; // enable HSE oscillator (off-chip
  for (volatile uint32_t i = 0; 				  for (volatile uint32_t i = 0; 
       i < HSE_STARTUP_TIMEOUT && !(RCC->CR & RCC_CR_HSERDY);	       i < HSE_STARTUP_TIMEOUT && !(RCC->CR & RCC_CR_HSERDY);
  { } // wait for either timeout or HSE to spin up		  { } // wait for either timeout or HSE to spin up
  FLASH->ACR = 0; // ensure the caches are turned off, so we 	  FLASH->ACR = 0; // ensure the caches are turned off, so we 
  FLASH->ACR = FLASH_ACR_DCRST | FLASH_ACR_ICRST; // flush th	  FLASH->ACR = FLASH_ACR_DCRST | FLASH_ACR_ICRST; // flush th
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | 		  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | 
               FLASH_ACR_DCEN | FLASH_ACR_LATENCY_5WS; // re-	               FLASH_ACR_DCEN | FLASH_ACR_LATENCY_5WS; // re-
  if (!(RCC->CR & RCC_CR_HSERDY))				  if (!(RCC->CR & RCC_CR_HSERDY))
    startup_clock_init_fail(); // go there and spin forever. 	    startup_clock_init_fail(); // go there and spin forever. 
  RCC->APB1ENR |= RCC_APB1ENR_PWREN; // clock up the power co	  RCC->APB1ENR |= RCC_APB1ENR_PWREN; // clock up the power co
  PWR->CR |= PWR_CR_VOS; // ensure the voltage regulator is a	  PWR->CR |= PWR_CR_VOS; // ensure the voltage regulator is a
                         // this will let us run at 168 MHz w	                         // this will let us run at 168 MHz w
  RCC->CFGR |= RCC_CFGR_HPRE_DIV1; // set HCLK (AHB clock) to	  RCC->CFGR |= RCC_CFGR_HPRE_DIV1; // set HCLK (AHB clock) to
  RCC->CFGR |= RCC_CFGR_PPRE2_DIV2; // set APB high-speed clo	  RCC->CFGR |= RCC_CFGR_PPRE2_DIV2; // set APB high-speed clo
  RCC->CFGR |= RCC_CFGR_PPRE1_DIV4; // set APB  low-speed clo	  RCC->CFGR |= RCC_CFGR_PPRE1_DIV4; // set APB  low-speed clo
  #define PLL_M  25						  #define PLL_M  25
  #define PLL_N 336						  #define PLL_N 336
  // PLL_VCO = 25 mhz / PLL_M * PLL_N = 336 MHz			  // PLL_VCO = 25 mhz / PLL_M * PLL_N = 336 MHz
  #define PLL_P   2						  #define PLL_P   2
  // SYSCLK = PLL_VCO / PLL_P = 168 MHz				  // SYSCLK = PLL_VCO / PLL_P = 168 MHz
  #define PLL_Q   7						  #define PLL_Q   7
  // USB clock = PLL_VCO / PLL_Q = 48 MHz			  // USB clock = PLL_VCO / PLL_Q = 48 MHz
  RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1)-1) << 	  RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1)-1) << 
                 (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);	                 (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);
  RCC->CR |= RCC_CR_PLLON; // start spinning up the PLL		  RCC->CR |= RCC_CR_PLLON; // start spinning up the PLL
  while (!(RCC->CR & RCC_CR_PLLRDY)) { } // wait until it's s	  while (!(RCC->CR & RCC_CR_PLLRDY)) { } // wait until it's s
  RCC->CFGR &= ~((uint32_t)RCC_CFGR_SW); // select internal o	  RCC->CFGR &= ~((uint32_t)RCC_CFGR_SW); // select internal o
  RCC->CFGR |= RCC_CFGR_SW_PLL; // select PLL as clock source	  RCC->CFGR |= RCC_CFGR_SW_PLL; // select PLL as clock source
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL) { } 	  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL) { } 
  // hooray we're done! we're now running at 168 MHz.		  // hooray we're done! we're now running at 168 MHz.
  main(); // jump to application main()				  main(); // jump to application main()
  while (1) { } // hopefully we never get here...		  while (1) { } // hopefully we never get here...
}								}

void unmapped_vector()						void unmapped_vector()
{								{
  while (1) { } // spin to allow jtag trap			  while (1) { } // spin to allow jtag trap
}								}

#define STACK_SIZE 0x4000					#define STACK_SIZE 0x4000
__attribute__((aligned(8),section(".stack"))) uint8_t g_stack	__attribute__((aligned(8),section(".stack"))) uint8_t g_stack

// declare weak symbols for all interrupt so they can be over	// declare weak symbols for all interrupt so they can be over
#define WEAK_VECTOR __attribute__((weak, alias("unmapped_vect	#define WEAK_VECTOR __attribute__((weak, alias("unmapped_vect
void nmi_vector() WEAK_VECTOR;					void nmi_vector() WEAK_VECTOR;
void hardfault_vector() WEAK_VECTOR;				void hardfault_vector() WEAK_VECTOR;
void memmanage_vector() WEAK_VECTOR;				void memmanage_vector() WEAK_VECTOR;
void busfault_vector() WEAK_VECTOR;				void busfault_vector() WEAK_VECTOR;
void usagefault_vector() WEAK_VECTOR;				void usagefault_vector() WEAK_VECTOR;
void svcall_vector() WEAK_VECTOR;				void svcall_vector() WEAK_VECTOR;
void dbgmon_vector() WEAK_VECTOR;				void dbgmon_vector() WEAK_VECTOR;
void pendsv_vector() WEAK_VECTOR;				void pendsv_vector() WEAK_VECTOR;
void systick_vector() WEAK_VECTOR;				void systick_vector() WEAK_VECTOR;
void wwdg_vector() WEAK_VECTOR;					void wwdg_vector() WEAK_VECTOR;
void pvd_vector() WEAK_VECTOR;					void pvd_vector() WEAK_VECTOR;
void tampstamp_vector() WEAK_VECTOR;				void tampstamp_vector() WEAK_VECTOR;
void rtc_wkup_vector() WEAK_VECTOR;				void rtc_wkup_vector() WEAK_VECTOR;
void flash_vector() WEAK_VECTOR;				void flash_vector() WEAK_VECTOR;
void rcc_vector() WEAK_VECTOR;					void rcc_vector() WEAK_VECTOR;
void exti0_vector() WEAK_VECTOR;				void exti0_vector() WEAK_VECTOR;
void exti1_vector() WEAK_VECTOR;				void exti1_vector() WEAK_VECTOR;
void exti2_vector() WEAK_VECTOR;				void exti2_vector() WEAK_VECTOR;
void exti3_vector() WEAK_VECTOR;				void exti3_vector() WEAK_VECTOR;
void exti4_vector() WEAK_VECTOR;				void exti4_vector() WEAK_VECTOR;
void dma1_stream0_vector() WEAK_VECTOR;				void dma1_stream0_vector() WEAK_VECTOR;
void dma1_stream1_vector() WEAK_VECTOR;				void dma1_stream1_vector() WEAK_VECTOR;
void dma1_stream2_vector() WEAK_VECTOR;				void dma1_stream2_vector() WEAK_VECTOR;
void dma1_stream3_vector() WEAK_VECTOR;				void dma1_stream3_vector() WEAK_VECTOR;
void dma1_stream4_vector() WEAK_VECTOR;				void dma1_stream4_vector() WEAK_VECTOR;
void dma1_stream5_vector() WEAK_VECTOR;				void dma1_stream5_vector() WEAK_VECTOR;
void dma1_stream6_vector() WEAK_VECTOR;				void dma1_stream6_vector() WEAK_VECTOR;
void adc_vector() WEAK_VECTOR;					void adc_vector() WEAK_VECTOR;
void can1_tx_vector() WEAK_VECTOR;				void can1_tx_vector() WEAK_VECTOR;
void can1_rx0_vector() WEAK_VECTOR;				void can1_rx0_vector() WEAK_VECTOR;
void can1_rx1_vector() WEAK_VECTOR;				void can1_rx1_vector() WEAK_VECTOR;
void can1_sce_vector() WEAK_VECTOR;				void can1_sce_vector() WEAK_VECTOR;
void exti9_5_vector() WEAK_VECTOR;				void exti9_5_vector() WEAK_VECTOR;
void tim1brk_tim9_vector() WEAK_VECTOR;				void tim1brk_tim9_vector() WEAK_VECTOR;
void tim1up_tim10_vector() WEAK_VECTOR;				void tim1up_tim10_vector() WEAK_VECTOR;
void tim1trg_tim11_vector() WEAK_VECTOR;			void tim1trg_tim11_vector() WEAK_VECTOR;
void tim1cc_vector() WEAK_VECTOR;				void tim1cc_vector() WEAK_VECTOR;
void tim2_vector() WEAK_VECTOR;					void tim2_vector() WEAK_VECTOR;
void tim3_vector() WEAK_VECTOR;					void tim3_vector() WEAK_VECTOR;
void tim4_vector() WEAK_VECTOR;					void tim4_vector() WEAK_VECTOR;
void i2c1_ev_vector() WEAK_VECTOR;				void i2c1_ev_vector() WEAK_VECTOR;
void i2c1_er_vector() WEAK_VECTOR;				void i2c1_er_vector() WEAK_VECTOR;
void i2c2_ev_vector() WEAK_VECTOR;				void i2c2_ev_vector() WEAK_VECTOR;
void i2c2_er_vector() WEAK_VECTOR;				void i2c2_er_vector() WEAK_VECTOR;
void spi1_vector() WEAK_VECTOR;					void spi1_vector() WEAK_VECTOR;
void spi2_vector() WEAK_VECTOR;					void spi2_vector() WEAK_VECTOR;
void usart1_vector() WEAK_VECTOR;				void usart1_vector() WEAK_VECTOR;
void usart2_vector() WEAK_VECTOR;				void usart2_vector() WEAK_VECTOR;
void usart3_vector() WEAK_VECTOR;				void usart3_vector() WEAK_VECTOR;
void exti15_10_vector() WEAK_VECTOR;				void exti15_10_vector() WEAK_VECTOR;
void rtc_alarm_vector() WEAK_VECTOR;				void rtc_alarm_vector() WEAK_VECTOR;
void otg_fs_wkup_vector() WEAK_VECTOR;				void otg_fs_wkup_vector() WEAK_VECTOR;
void tim8brk_tim12_vector() WEAK_VECTOR;			void tim8brk_tim12_vector() WEAK_VECTOR;
void tim8up_tim13_vector() WEAK_VECTOR;				void tim8up_tim13_vector() WEAK_VECTOR;
void tim8trg_tim14_vector() WEAK_VECTOR;			void tim8trg_tim14_vector() WEAK_VECTOR;
void tim8cc_vector() WEAK_VECTOR;				void tim8cc_vector() WEAK_VECTOR;
void dma1_stream7_vector() WEAK_VECTOR;				void dma1_stream7_vector() WEAK_VECTOR;
void fsmc_vector() WEAK_VECTOR;					void fsmc_vector() WEAK_VECTOR;
void sdio_vector() WEAK_VECTOR;					void sdio_vector() WEAK_VECTOR;
void tim5_vector() WEAK_VECTOR;					void tim5_vector() WEAK_VECTOR;
void spi3_vector() WEAK_VECTOR;					void spi3_vector() WEAK_VECTOR;
void uart4_vector() WEAK_VECTOR;				void uart4_vector() WEAK_VECTOR;
void uart5_vector() WEAK_VECTOR;				void uart5_vector() WEAK_VECTOR;
void tim6_dac_vector() WEAK_VECTOR;				void tim6_dac_vector() WEAK_VECTOR;
void tim7_vector() WEAK_VECTOR;					void tim7_vector() WEAK_VECTOR;
void dma2_stream0_vector() WEAK_VECTOR;				void dma2_stream0_vector() WEAK_VECTOR;
void dma2_stream1_vector() WEAK_VECTOR;				void dma2_stream1_vector() WEAK_VECTOR;
void dma2_stream2_vector() WEAK_VECTOR;				void dma2_stream2_vector() WEAK_VECTOR;
void dma2_stream3_vector() WEAK_VECTOR;				void dma2_stream3_vector() WEAK_VECTOR;
void dma2_stream4_vector() WEAK_VECTOR;				void dma2_stream4_vector() WEAK_VECTOR;
void eth_vector() WEAK_VECTOR;					void eth_vector() WEAK_VECTOR;
void eth_wkup_vector() WEAK_VECTOR;				void eth_wkup_vector() WEAK_VECTOR;
void can2_tx_vector() WEAK_VECTOR;				void can2_tx_vector() WEAK_VECTOR;
void can2_rx0_vector() WEAK_VECTOR;				void can2_rx0_vector() WEAK_VECTOR;
void can2_rx1_vector() WEAK_VECTOR;				void can2_rx1_vector() WEAK_VECTOR;
void can2_sce_vector() WEAK_VECTOR;				void can2_sce_vector() WEAK_VECTOR;
void otg_fs_vector() WEAK_VECTOR;				void otg_fs_vector() WEAK_VECTOR;
void dma2_stream5_vector() WEAK_VECTOR;				void dma2_stream5_vector() WEAK_VECTOR;
void dma2_stream6_vector() WEAK_VECTOR;				void dma2_stream6_vector() WEAK_VECTOR;
void dma2_stream7_vector() WEAK_VECTOR;				void dma2_stream7_vector() WEAK_VECTOR;
void usart6_vector() WEAK_VECTOR;				void usart6_vector() WEAK_VECTOR;
void i2c3_ev_vector() WEAK_VECTOR;				void i2c3_ev_vector() WEAK_VECTOR;
void i2c3_er_vector() WEAK_VECTOR;				void i2c3_er_vector() WEAK_VECTOR;
void otg_hs_ep1_out_vector() WEAK_VECTOR;			void otg_hs_ep1_out_vector() WEAK_VECTOR;
void otg_hs_ep1_in_vector() WEAK_VECTOR;			void otg_hs_ep1_in_vector() WEAK_VECTOR;
void otg_hs_wkup_vector() WEAK_VECTOR;				void otg_hs_wkup_vector() WEAK_VECTOR;
void otg_hs_vector() WEAK_VECTOR;				void otg_hs_vector() WEAK_VECTOR;
void dcmi_vector() WEAK_VECTOR;					void dcmi_vector() WEAK_VECTOR;
void cryp_vector() WEAK_VECTOR;					void cryp_vector() WEAK_VECTOR;
void hash_rng_vector() WEAK_VECTOR;				void hash_rng_vector() WEAK_VECTOR;
void fpu_vector() WEAK_VECTOR;					void fpu_vector() WEAK_VECTOR;
void uart7_vector() WEAK_VECTOR;				void uart7_vector() WEAK_VECTOR;
void uart8_vector() WEAK_VECTOR;				void uart8_vector() WEAK_VECTOR;
void spi4_vector() WEAK_VECTOR;					void spi4_vector() WEAK_VECTOR;
void spi5_vector() WEAK_VECTOR;					void spi5_vector() WEAK_VECTOR;
void spi6_vector() WEAK_VECTOR;					void spi6_vector() WEAK_VECTOR;
void sai1_vector() WEAK_VECTOR;					void sai1_vector() WEAK_VECTOR;
void ltdc_vector() WEAK_VECTOR;					void ltdc_vector() WEAK_VECTOR;
void ltdc_er_vector() WEAK_VECTOR;				void ltdc_er_vector() WEAK_VECTOR;
void dma2d_vector() WEAK_VECTOR;				void dma2d_vector() WEAK_VECTOR;

typedef void (*vector_func_t)();				typedef void (*vector_func_t)();
__attribute__((section(".vectors"))) vector_func_t g_vectors[	__attribute__((section(".vectors"))) vector_func_t g_vectors[
{								{
    (vector_func_t)(&g_stack[STACK_SIZE-8]), // initial stack	    (vector_func_t)(&g_stack[STACK_SIZE-8]), // initial stack
    reset_vector,						    reset_vector,
    nmi_vector,							    nmi_vector,
    hardfault_vector,						    hardfault_vector,
    memmanage_vector,						    memmanage_vector,
    busfault_vector,						    busfault_vector,
    usagefault_vector,						    usagefault_vector,
    0, 0, 0, 0,  						    0, 0, 0, 0,  
    svcall_vector,						    svcall_vector,
    dbgmon_vector,						    dbgmon_vector,
    0,                                      			    0,                                      
    pendsv_vector,						    pendsv_vector,
    systick_vector,						    systick_vector,
    wwdg_vector,       // 0					    wwdg_vector,       // 0
    pvd_vector,        						    pvd_vector,        
    tampstamp_vector,						    tampstamp_vector,
    rtc_wkup_vector,						    rtc_wkup_vector,
    flash_vector,						    flash_vector,
    rcc_vector,							    rcc_vector,
    exti0_vector,						    exti0_vector,
    exti1_vector,						    exti1_vector,
    exti2_vector,						    exti2_vector,
    exti3_vector,						    exti3_vector,
    exti4_vector,      // 10					    exti4_vector,      // 10
    dma1_stream0_vector,					    dma1_stream0_vector,
    dma1_stream1_vector,					    dma1_stream1_vector,
    dma1_stream2_vector,					    dma1_stream2_vector,
    dma1_stream3_vector,					    dma1_stream3_vector,
    dma1_stream4_vector,					    dma1_stream4_vector,
    dma1_stream5_vector,					    dma1_stream5_vector,
    dma1_stream6_vector,					    dma1_stream6_vector,
    adc_vector,							    adc_vector,
    can1_tx_vector,						    can1_tx_vector,
    can1_rx0_vector,   // 20					    can1_rx0_vector,   // 20
    can1_rx1_vector,						    can1_rx1_vector,
    can1_sce_vector,						    can1_sce_vector,
    exti9_5_vector,						    exti9_5_vector,
    tim1brk_tim9_vector,					    tim1brk_tim9_vector,
    tim1up_tim10_vector,					    tim1up_tim10_vector,
    tim1trg_tim11_vector,					    tim1trg_tim11_vector,
    tim1cc_vector,						    tim1cc_vector,
    tim2_vector,						    tim2_vector,
    tim3_vector,						    tim3_vector,
    tim4_vector,						    tim4_vector,
    i2c1_ev_vector,						    i2c1_ev_vector,
    i2c1_er_vector,						    i2c1_er_vector,
    i2c2_ev_vector,						    i2c2_ev_vector,
    i2c2_er_vector,						    i2c2_er_vector,
    spi1_vector,						    spi1_vector,
    spi2_vector,						    spi2_vector,
    usart1_vector,						    usart1_vector,
    usart2_vector,						    usart2_vector,
    usart3_vector,						    usart3_vector,
    exti15_10_vector,						    exti15_10_vector,
    rtc_alarm_vector,						    rtc_alarm_vector,
    otg_fs_wkup_vector,						    otg_fs_wkup_vector,
    tim8brk_tim12_vector,					    tim8brk_tim12_vector,
    tim8up_tim13_vector,					    tim8up_tim13_vector,
    tim8trg_tim14_vector,					    tim8trg_tim14_vector,
    tim8cc_vector,						    tim8cc_vector,
    dma1_stream7_vector,					    dma1_stream7_vector,
    fsmc_vector,						    fsmc_vector,
    sdio_vector,						    sdio_vector,
    tim5_vector,						    tim5_vector,
    spi3_vector,						    spi3_vector,
    uart4_vector,						    uart4_vector,
    uart5_vector,						    uart5_vector,
    tim6_dac_vector,						    tim6_dac_vector,
    tim7_vector,						    tim7_vector,
    dma2_stream0_vector,					    dma2_stream0_vector,
    dma2_stream1_vector,					    dma2_stream1_vector,
    dma2_stream2_vector,					    dma2_stream2_vector,
    dma2_stream3_vector,					    dma2_stream3_vector,
    dma2_stream4_vector,					    dma2_stream4_vector,
    eth_vector,							    eth_vector,
    eth_wkup_vector,						    eth_wkup_vector,
    can2_tx_vector,						    can2_tx_vector,
    can2_rx0_vector,						    can2_rx0_vector,
    can2_rx1_vector,						    can2_rx1_vector,
    can2_sce_vector,						    can2_sce_vector,
    otg_fs_vector,						    otg_fs_vector,
    dma2_stream5_vector,					    dma2_stream5_vector,
    dma2_stream6_vector,					    dma2_stream6_vector,
    dma2_stream7_vector,					    dma2_stream7_vector,
    usart6_vector,						    usart6_vector,
    i2c3_ev_vector,						    i2c3_ev_vector,
    i2c3_er_vector,						    i2c3_er_vector,
    otg_hs_ep1_out_vector,					    otg_hs_ep1_out_vector,
    otg_hs_ep1_in_vector,					    otg_hs_ep1_in_vector,
    otg_hs_wkup_vector,						    otg_hs_wkup_vector,
    otg_hs_vector,						    otg_hs_vector,
    dcmi_vector,						    dcmi_vector,
    cryp_vector,						    cryp_vector,
    hash_rng_vector,						    hash_rng_vector,
    fpu_vector,							    fpu_vector,
    uart7_vector,						    uart7_vector,
    uart8_vector,						    uart8_vector,
    spi4_vector,						    spi4_vector,
    spi5_vector,						    spi5_vector,
    spi6_vector,						    spi6_vector,
    sai1_vector,						    sai1_vector,
    ltdc_vector,						    ltdc_vector,
    ltdc_er_vector,						    ltdc_er_vector,
    dma2d_vector						    dma2d_vector
};								};

diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/state.c /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/state.c
#include "state.h"						#include "state.h"

// GLOBAL ALL FILES VARIABLES				      |	volatile state_t g_state;
volatile state_t handState;				      <
volatile status_t handStatus;				      <

void state_init()						void state_init()
{								{
	// initializing handState			      |	  g_state.header[0] = 0x01; // version number of this state f
	handState.header[0] = 0x01; // version number of this |	  g_state.header[1] = 0x00; // pad 3 bytes so we get 32 bit a
	handState.header[1] = 0x00; // pad 3 bytes so we get  |	  g_state.header[2] = 0x00; // ditto
	handState.header[2] = 0x00; // ditto		      |	  g_state.header[3] = 0x00; // ditto
	handState.header[3] = 0x00; // ditto		      |	  g_state.systime = 0;
	handState.header[4] = 0x00; // ditto		      |	  for (uint_fast8_t i = 0; i < NUM_SENSORS; i++)
	handState.header[5] = 0x00; // ditto		      |	    g_state.tactile_pressures[i] = g_state.tactile_temperatur
	handState.systime = 0;				      |	  for (uint_fast8_t i = 0; i < NUM_ENC; i++)
	for (uint_fast8_t i = 0; i < NUM_SENSORS; i++)	      |	    g_state.encoders[i] = 0;
		handState.takktile_pressures[i] = handState.t <
	for (uint_fast8_t i = 0; i < NUM_ENC; i++)	      <
		handState.encoders[i] = 0;		      <
	for (uint_fast8_t i = 0; i < NUM_IMUS*4; i++)	      <
	    handState.imus[i] = 0;			      <
							      <
	// initializing handStatus			      <
	for (uint_fast8_t i = 0; i < NUM_FINGERS; i++)	      <
		handStatus.finger[i] = 1;		      <
	for (uint_fast8_t i = 0; i < NUM_SENSORS; i++)	      <
		handStatus.takktileSensor[i] = 1;	      <
	for (uint_fast8_t i = 0; i < NUM_ENC; i++)	      <
		handStatus.encoders[i] = 1;		      <
	for (uint_fast8_t i = 0; i < NUM_IMUS; i++)	      <
	    handStatus.imus[i] = 0;			      <
}								}

diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/state.h /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/state.h
#ifndef STATE_H							#ifndef STATE_H
#define STATE_H							#define STATE_H

#include <stdint.h>						#include <stdint.h>
#include "reflex.h"					      |	#include "tactile.h"
							      >	#include "enc.h"

typedef struct							typedef struct
{								{
  uint8_t  header[6];                          // 0-3	      |	  uint8_t  header[4];                         // 0-3
  uint32_t systime;                            // 4-7	      |	  uint32_t systime;                           // 4-7
  uint16_t takktile_pressures[NUM_SENSORS];    // 8-83	      |	  uint16_t tactile_pressures[NUM_SENSORS];    // 8-83
  uint16_t takktile_temperatures[NUM_SENSORS]; // 84-159      |	  uint16_t tactile_temperatures[NUM_SENSORS]; // 84-159
  uint16_t encoders[NUM_ENC];                  // 160-165     |	  uint16_t encoders[NUM_ENC];                 // 160-165
  uint8_t  dynamixel_error_status[4];          // 166-169     |	  uint8_t  dynamixel_error_status[4];         // 166-169
  uint16_t dynamixel_angles[4];                // 170-177     |	  uint16_t dynamixel_angles[4];               // 170-177
  uint16_t dynamixel_speeds[4];					  uint16_t dynamixel_speeds[4];
  uint16_t dynamixel_loads[4];					  uint16_t dynamixel_loads[4];
  uint8_t  dynamixel_voltages[4];				  uint8_t  dynamixel_voltages[4];
  uint8_t  dynamixel_temperatures[4];				  uint8_t  dynamixel_temperatures[4];
  uint16_t imus[NUM_IMUS*4];                   // 160-165     <
} __attribute__((packed)) state_t;				} __attribute__((packed)) state_t;

typedef struct						      |	extern volatile state_t g_state;
{							      <
  uint8_t finger[NUM_FINGERS];                 // 0-2	      <
  uint8_t takktileSensor[NUM_SENSORS];         // 3-11	      <
  uint8_t encoders[NUM_ENC];                   // 12-14	      <
  uint8_t imus[NUM_IMUS];				      <
} __attribute__((packed)) status_t;			      <
							      <
// Values meaning:					      <
// finger						      <
//     0: not responding				      <
//     1: responding					      <
							      <
// takktileSensor					      <
//     0: not responding				      <
//     1: responding					      <
							      <
// encoders						      <
//     0: not responding				      <
//     1: responding					      <
							      <
extern volatile state_t handState;			      <
extern volatile status_t handStatus;			      <

void state_init();						void state_init();

#endif								#endif

Common subdirectories: /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/stm32 and /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/stm32
diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/stubs.c /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/stubs.c
#include <stdlib.h>						#include <stdlib.h>
#include <stdio.h>						#include <stdio.h>
#include <sys/stat.h>						#include <sys/stat.h>
#include "console.h"						#include "console.h"

/* UART DEBUGGING					      <
*     true if you want to debug via UART, using the 4 pins on <
*     false, if you want a faster normal functioning	      <
*/							      <
#define DEBUG_VIA_UART true				      <
							      <
extern int _end;						extern int _end;

caddr_t _sbrk(int incr)						caddr_t _sbrk(int incr)
{								{
  static unsigned char *heap = NULL ;				  static unsigned char *heap = NULL ;
  unsigned char *prev_heap ;					  unsigned char *prev_heap ;
  if ( heap == NULL )						  if ( heap == NULL )
    heap = (unsigned char *)&_end ;				    heap = (unsigned char *)&_end ;
  prev_heap = heap;						  prev_heap = heap;
  heap += incr ;						  heap += incr ;
  return (caddr_t) prev_heap ;					  return (caddr_t) prev_heap ;
}								}

int _kill(__attribute__((unused)) int pid, 			int _kill(__attribute__((unused)) int pid, 
          __attribute__((unused)) int sig) { return -1; }	          __attribute__((unused)) int sig) { return -1; }
void _exit(__attribute__((unused)) int status) { while (1) {}	void _exit(__attribute__((unused)) int status) { while (1) {}
int _getpid() { return 1; }					int _getpid() { return 1; }

int _write(__attribute__((unused)) int fd, const void *buf, s	int _write(__attribute__((unused)) int fd, const void *buf, s
{								{
  #if DEBUG_VIA_UART == true				      |	  console_send_block((uint8_t *)buf, count);
    consolePrint((uint8_t *)buf, count);		      <
  #endif						      <
  return count;							  return count;
}								}
int _close(__attribute__((unused)) int fd) { return -1; }	int _close(__attribute__((unused)) int fd) { return -1; }
int _fstat(__attribute__((unused)) int fd, 			int _fstat(__attribute__((unused)) int fd, 
           __attribute__((unused)) struct stat *st)		           __attribute__((unused)) struct stat *st)
{								{
  st->st_mode = S_IFCHR;					  st->st_mode = S_IFCHR;
  return 0;							  return 0;
}								}
int _isatty(__attribute__((unused)) int fd) { return 1; }	int _isatty(__attribute__((unused)) int fd) { return 1; }
off_t _lseek(__attribute__((unused)) int fd, 			off_t _lseek(__attribute__((unused)) int fd, 
             __attribute__((unused)) off_t offset, 		             __attribute__((unused)) off_t offset, 
             __attribute__((unused)) int whence) { return 0; 	             __attribute__((unused)) int whence) { return 0; 
ssize_t _read(__attribute__((unused)) int fd, 			ssize_t _read(__attribute__((unused)) int fd, 
              __attribute__((unused)) void *buf, 		              __attribute__((unused)) void *buf, 
              __attribute__((unused)) size_t count) { return 	              __attribute__((unused)) size_t count) { return 

struct __FILE { int handle; };					struct __FILE { int handle; };
FILE __stdout;							FILE __stdout;
FILE __stderr;							FILE __stderr;
int fputc(__attribute__((unused)) int ch, __attribute__((unus	int fputc(__attribute__((unused)) int ch, __attribute__((unus
{								{
  return 0;							  return 0;
}								}
void _ttywrch(__attribute__((unused)) int ch) { }		void _ttywrch(__attribute__((unused)) int ch) { }

diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/systime.c /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/systime.c
#include "systime.h"						#include "systime.h"
#include "./stm32/stm32f4xx.h"				      |	#include "stm32f4xx.h"

void systime_init()						void systime_init()
{								{
  // TIM2 is a 32-bit counter. it just counts microseconds si	  // TIM2 is a 32-bit counter. it just counts microseconds si
  RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;				  RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
  for (volatile int i = 0; i < 1000; i++) { } // let tim2 spi	  for (volatile int i = 0; i < 1000; i++) { } // let tim2 spi
  TIM2->PSC = 168000000 / 2 / 1000000 - 1; // 83		  TIM2->PSC = 168000000 / 2 / 1000000 - 1; // 83
  TIM2->ARR = 0xffffffff; // count as long as possible		  TIM2->ARR = 0xffffffff; // count as long as possible
  TIM2->EGR = TIM_EGR_UG; // load the PSC register immediatel	  TIM2->EGR = TIM_EGR_UG; // load the PSC register immediatel
  TIM2->CR1 = TIM_CR1_CEN; // start counter			  TIM2->CR1 = TIM_CR1_CEN; // start counter
}							      <
							      <
void udelay(int utime)					      <
{							      <
  int mytime = SYSTIME;					      <
  while(SYSTIME - mytime < utime);			      <
}								}

diff -y /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/systime.h /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/systime.h
#ifndef SYSTIME_H						#ifndef SYSTIME_H
#define SYSTIME_H						#define SYSTIME_H

#include "./stm32/stm32f4xx.h"				      |	#include "stm32f4xx.h"
							      <
#define SYSTIME (TIM2->CNT)				      <

void systime_init();						void systime_init();
void udelay(int utime);					      |	#define SYSTIME (TIM2->CNT)

#endif								#endif

Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/: tactile.c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-takktile/: tactile.h
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: takktile (almost no mod from original).c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: takktile (backup).c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: takktile (backup, i2c multiple for 3, single for 1 and 2) .c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: takktile.c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: takktile (finger 2 standalone, g_state).c
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: takktile.h
Only in /home/reflex2/catkin_ws/src/reflex-ros-pkg/firmware/reflex-firmware-master/: takktile (working takktiles individual).c
